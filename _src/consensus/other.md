
## vector of clock time can not be used. non-partially-ordered.

如果使用一个event在多个replica上真实发生的时间作为vector time的时间分量, 这个vector time不是一个[偏序关系]的集合, 所以不能用来实现一致性, 这是因为每个时间分量是任意值, 总是能构造出 `a < b < c < a` 这样的不遵循传递性的例子:

我们可以给vector time定义一个偏序关系: 

- 例如要求所有分量都大于才才大于.

- 或者要求所有分量之和大于才大于.

但分布式系统中需要对部分宕机有一定的容忍, 所以T(e) 中的时间分量不能保证都被读到. 所以vector time必须能只有几个分量就能确认大小.

假设一个event e 写到几个replica上并返回结果给client, 那么client可以得到e的每个时间分量, 以及每个replica上e发生之前的所有event及其各自的时间分量. 这时 proposer 需要根据自己定义的某种vector time的大小关系比较

假设有ABC三个vector time, 

- AB之间只需Tab来确定大小, 
- BC之间只需Tbc来确定大小
- AC之间只需Tac来确定大小

如果Tab, Tbc, Tac之间没有交集, 那么就可以通过互换A和C上Tac分量的值来制造一个**违反传递性**的例子.

如果有交集, 例如Tab和Tac, 那么就从ABC中去掉交集中的分量, 制造一个互相没有交集的例子, 同样可以制造出一个违反传递性的例子.

所以, 就要求如果A存在, 就必须读到Tab和Tac交集上的时间, 才能比较大小. 因为在分布式系统中不知道要比较哪些变量, 就要求所有分量都必须能读到, 这违反了分布式中只需部分分量就能工作的要求.

所以分布式系统中, 不能直接使用clock time的vector 来作为时间. **否则或者因为不能构造偏序时间而无法达成一致性, 或者能读到全部节点上的时间**.
