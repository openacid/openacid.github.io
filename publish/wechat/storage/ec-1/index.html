<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Erasure-Code-擦除码-1-原理篇 - OpenACID Blog</title>
<meta name="description" content="前言做分布式存储的同学, 一定都知道一个了不地的冗余算法叫作擦除码(Erasure-Code), 它让存储以多副本几分之一的成本来达到同样高的可靠性.虽然web上有很多介绍EC的文字,但几乎所有这些文字都为了严(bi)谨(ge)而搞的像牛津词典一样难读,懂的人不需要看, 不懂的人看不懂.能把事情给人讲明白, 文字才有用.于是准备了这3篇介绍EC的文字, 我敢肯定, 你没看过这样通(di)俗(diao)易(she)懂(hua)的EC教程.看完这3篇文字! 保你可以徒手写出一个EC存储系统, 本文是第一部分:  第一篇:原理  第二篇:实现  第三篇:极限(疯狂编辑中)问题分布式系统的第一个问题是可靠解决了数据可靠性的问题之后,数据的其他问题如一致性, 性能, 可用性等的讨论才有意义.然而现实残酷, 存储的硬件设备总是不够可靠. 下图摘自 backblaze发布的硬盘故障率统计此外, 服务器还会宕机,磁盘会掉,光纤会被挖掘机铲断, 机房会被大雨淹没.因此数据的存储必须要做到在部分硬件故障时还能保证正常读(或读写), 才可以达到工业可用的可靠性.而提高可靠性最直接最简单的方法, 就是 对一份数据存储多个副本(副本数一般选择3).  结合目前经验上的磁盘的损坏率(大约是年损坏率7%),3个副本可以达到一个工业可接受的可靠性,这个可靠性的预期大约是11个9以上(99.999999999%的概率不丢数据).  有些时候为了降低成本, 只存储2个副本, 也可以达到8个9的可靠性.3副本的方式虽然简单容易实现, 但要额外浪费2倍的存储空间,因此存储领域中一直都希望用一种较少的冗余的存储方式, 来实现同样较高的可靠性.不论是单机上的RAID技术, 还是今天要提到的EC(Erasure-Code, 擦除码, 纠删码)都是用来解决这个问题的. 接下来, 我们通过几个例子, 来逐步展示 EC 的工作原理.  RAID 本质上跟EC没有区别, 它是单机系统时代被广泛使用的成熟实现.EC可以认为是分布式系统发展起来后, RAID算法在多机系统上的重新实现:      RAID-0 相当于单副本;    RAID-1 相当于2副本;    RAID-5 相当于EC的k+1模式, k个数据块+1个校验块;    RAID-6 相当于EC的k+2模式, k个数据块+2个校验块;  EC的基本原理EC的目标可以简单的理解为: 对k个同样大小的数据块,额外增加m个校验块,以使得这k+m个数据中任意丢失m个数据块/校验块时都能把丢失的数据找回.栗子1: 实现k+1的冗余策略🌰Q: 有3个自然数, 能否做到再记录第4个数字,让任何一个数字丢失的时候都可以将其找回?这个问题很简单, 记录这3个数字的和:假设3个数字是: d₁, d₂, d₃ ;再存储一个 y₁ = d₁ + d₂ + d₃ 就可以了.于是:      存储过程:    就是存储这4个数字: d₁, d₂, d₃, y₁.        恢复过程:                  如果 d₁, d₂, d₃ 任意一个丢失, 例如 d₁ 丢失了,我们都可以通过 d₁ = y₁ - d₂ - d₃ 来得到 d₁ .                    如果 y₁ 丢失, 则再次取 d₁ + d₂ + d₃ 的和就可以将 y₁ 找回.            这种求和冗余策略, 就是 EC 算法的核心.在上面这个简单的系统中, 总共存储了4份数据, 有效的数据是3份. 冗余是133%,它的可靠性和2副本的200%冗余的存储策略差不多: 最多允许丢失1份数据.            策略      冗余度      可靠性      存储策略示意                  2副本      200%      允许丢1块: 1 X 10⁻⁸      (d₁,d₁), (d₂,d₂), (d₃,d₃)              3+1求和冗余      133%      允许丢1块: 6 X 10⁻⁸      (d₁, d₂, d₃, y₁)        这里还只是差不多, 虽然都是允许丢失1块数据, 但还并不是完全一样,后面详细讨论可靠性的计算.在讨论可靠性的时候, 一般数据丢失风险没有量级的差异, 就可以认为是比较接近的.  上面这个k+1的例子是和我们平时使用的 RAID-5 是类似的.RAID-5 通过对k个(可能是11个左右)数据块求出1份校验和的数据块.存储这份校验块, 并允许1块(数据或校验)丢失后可以找回.  但在工程上, RAID-5 的计算并不是自然数的求和, 而是用bit-AND操作代替加法的. 后面细聊.栗子2: 实现k+2的冗余策略🌰🌰现在我们在k+1的冗余策略基础上, 尝试增加更多的校验块, 来实现任意k+2的冗余策略.Q: 有3块数据:  d₁, d₂, d₃可否另外再存储2个冗余的校验块(共5块), 让整个系统任意丢失2份数据时都能找回?在k+1求和的策略里, 我们给数据块和校验块建立了一个方程, 把它们关联起来了:y₁ = d₁ + d₂ + d₃.现在, 如果要增加可丢失的块数, 简单的把 y₁ 存2次是不够的.  例如我们存储了2个校验块:              存储过程:      存储 d₁, d₂, d₃, y₁, y₂ 这5个数字.              恢复过程:      如果 d₁, d₂ 都丢失了(用 u₁, u₂ 表示丢失的数据),下面这个关于 u₁, u₂ 的线性方程是有无穷多解的:            我们没有办法从这个方程组里解出 u₁, u₂ 的值, 因为第2个方程跟第1个一毛一样,没有提供更多的信息.      所以我们现在需要做的是, 对第2个校验块 y₂, 设计一个新的计算方法, 使之跟3个数据块之间建立一个不同的关联,使得当 d₁, d₂ 丢失时方程组有解:我们采用的方式是, 在计算 y₂  时, 给每个数据 dⱼ 设置不同的系数:  计算 y₁ 时, 对每个数字乘以1, 1, 1, 1 …  计算 y₂ 时, 对每个数字乘以1, 2, 4, 8 …按照此方案, 我们就可以建议一个k+2的存储系统:      存储过程:    存储 d₁, d₂, d₃, y₁, y₂ 这5个数字.        数据恢复:    如果 d₁ 或 d₂ 之一丢失,恢复的过程跟k+1策略一样;    如果 d₁, d₂ 丢失(同样用 u₁, u₂ 表示),我们可以使用剩下的3个数字 d₃, y₁, y₂来建里1个关于 u₁, u₂ 的二元一次方程组:  解出上面这个方程组, 就找回了丢失的 u₁, u₂ .  以上这种加系数计算校验块的方式, 就是RAID-6的基本工作方式:  RAID-6为k个数据块(例如k=10)之外再多存储2个校验数据,当整个系统丢失2块数据时, 都可以找回.  为什么计算 y₂ 的系数是1, 2, 4, 8…? 系数的选择有很多种方法, 1, 2, 4, 8是其中一个.只要保证最终丢失2个数字构成的方程组有唯一解就可以.在k+2的场景中, 选择1, 2, 3, 4…作为系数也可以.到这里我们就得到了k+2的EC的算法:通过166%的冗余, 实现差不多和三副本300%冗余一样的可靠性.栗子3: 实现k+m的冗余策略🌰🌰🌰如果要增加更多的冗余,让EC来实现相当于4副本差不多的可靠性: k+3,我们需要给上面的策略再增加一个校验块 y₃ ,而 y₃ 的计算我们需要再为所有的 dⱼ 选择1组不同的系数,例如1,3,9,27…来保证后面数据丢失时,得到的1个3元一次方程组是可解的:这样我们通过不断的增加不同的系数, 就可以得到任意的k+m的EC冗余存储策略的实现.到此为止, 就是EC算法的核心思想了.接下来, 我们再深入1点, 从另外1个角度来解释下为什么要选择这样1组系数.  现实中使用的RAID-5和RAID-6都是 EC 算法的子集.EC 是更具通用性的算法. 但因为实现的成本(主要是恢复数据时的计算开销), RAID-5 和RAID-6在单机的可靠性实现中还是占主流地位.  但随着存储量的不断增大, 百PB的存储已经不算是很极端场景了.RAID-6 在单机环境下不算高的数据丢失风险在大数据量的场景中显示的越来越明显.于是在云存储(大规模存储)领域, 能支持更多的冗余校验块的EC成为了主流.EC的几何解释上面介绍了如何选择 EC 生成校验块(编码过程)的系数,我们隐约可以感觉到它的系数选择可能有某种内涵,接下来我们回到最初的问题, 思索下为什么要使用这样1组系数.我们从比较简单的情况开始, 看下2个数据块计算(多个)校验块的方法:2+m的冗余的本质: 两点确定一条直线假设 现在我们有2个数据块 d₁, d₂. 要做2个校验块.我们使用1个直线的方程, 把 d₁, d₂ 作为系数, 来实现数据的冗余备份和恢复:这条直线具备这样的特点:  这条直线包含的所有数据块 dⱼ 的信息:          任何1对 d₁, d₂ 的值就确定一条不同的直线.      同样, 任意1条直线也唯一对应1对 d₁, d₂ 的值.      数据可靠性的问题就转化成了:  我们要保存足够多的关于这条直线的信息, 能够在需要的时候找回这条直线.  然后再提取直线方程的系数来找回最初存储的数据块 d₁, d₂.要保存足够多的信息, 最直观的方法就是记录这条直线上的几个点的坐标.  例如假设要存储的数据d₁ d₂ 分别是5, 6, 则直线方程是: y = 5 + 6x.记录直线上x=1, 2 时y的值, 如下图:  因为2点可以确定一条直线, 只要拿到直线上2个点的坐标, 就能确定直线方程,从而确定它的系数 d₁, d₂ .按照这样的思路, 我们重新用直线方程的方式描述数据冗余生成和数据恢复的过程:      存储过程:    以 d₁, d₂ 作为系数建立一个直线方程,再在直线上取2个点,记录点的坐标(这里我们总是取x = [1, 2, 3…]的自然数的值,所以只记录y的值就可以了): d₁, d₂, (1, y₁), (2, y₂).        恢复过程:    已知过直线2点 (1, y₁), (2, y₂) 来确定直线方程, 再提取方程的系数.  在这个校验块跟数据块的关系中:丢失1个数据块时只用 y₁ 的方程就够了.丢失2个数据块时才需要解二元一次方程组. 如果 y₁ 或 y₂ 丢失, 则通过重新取点的方式恢复.  我们可以在直线上取任意多个点, 但恢复时最多也只需要2个点就够了.k+m的冗余的本质: 高次曲线现在我们把它再推广到更一般的情况:直线方程只有2个系数  d₁, d₂ , 只能用于对2块数据做冗余,如果要用描点方式来为更多的数据块生成冗余数据,我们就需要有更多系数的方程, 也就是使用高次的曲线.  例如:二次曲线抛物线 y = a x² + b x + c 需要3个系数来确定(可用来存储3块数据),同时也需要知道抛物线上的3个点的坐标来找回这条抛物线.如果有k个数据块, 我们把k个数据作为系数, 来定义1条关于x的高次曲线,再通过记录曲线上的点的坐标来实现冗余:  例如要存储4个数据1, 2, 3, 4, 则曲线方程是: y = 1 + 2x + 3x² + 4x³.记录曲线上x=1, 2, 3, 4 时y的值, 如下图:        存储过程:    取m个不同的x的值(1, 2, 3…m), 记录这条曲线上m个不同点的坐标:        存储所有k个数据块 d₁, d₂ ....和所有m个校验块 y₁, y₂ ....        恢复过程:    平面上m个点可以唯一确定1条 m-1次幂的曲线(或通过m个点跟k-m个已知系数确定一条k-1次幂的曲线).确定了这条关于x的曲线,就找回了它的系数,也就是数据块      以上就是 EC存储跟恢复的几何本质:一条k-1次曲线可以通过k个系数或曲线上的点来确定.从曲线方程到生成矩阵从EC的几何本质出发, 我们再系统的描述下生成校验块的过程:为x取自然数的值(1,2,3…)来计算 y 的值:把上面等式写成矩阵的形式, 就得到了EC校验块的 生成矩阵 Generator-Matrix:这里 y₁, y₂ ... 就是校验块的数据,因此, 上面栗子3中选择的系数, 就是从这里来的.而这个矩阵, 就是著名的 Vandermonde 矩阵.  Vandermonde 矩阵只是 EC 其中1种系数的选择方式.其他常用的系数矩阵还有 Cauchy 矩阵等.EC的解码: 求解n元一次方程组EC生成校验块的过程称之为EC的编码,也就是用Vandermonde矩阵去乘所有的数据块.而当数据丢失需要找回的时候,使用的是EC的解码过程.既然EC的编码过程是编码矩阵(Vandermonde)和数据块列相乘:那么解码的过程就可以描述如下:假设有q个数字丢失了, q &lt;= m.从上面的编码矩阵中选择q行,组成的一次方程组, 求解方程组算出丢失的数据.例如 d₂, d₃ 丢失了, 下面用 u₂, u₃ 表示(只丢失了2块数据, 不需要所有的m个校验块参与, 只需要2个校验块来恢复数据)这个矩阵表示的方程组里有2个未知数 u₂, u₃ ,解方程即可得到 u₂, u₃ 这2块丢失的数据.Vandermonde 矩阵保证方程组有解对于k+m的EC来说, 任意丢失m个数据块都可以将其找回.因为我们选择的Vandermonde 矩阵保证了任意m行m列组成的子矩阵都是线性无关的,构成的方程肯定有确定解. 例如:      Vandermonde 的 行列式的值为:        只要 xᵢ 都不同, 则 Vandermonde 矩阵的行列式就不为0, 矩阵可逆, 表示方程有唯一解.        Vandermonde 矩阵的任意 m x m 的子矩阵, 是一个Generalized Vandermonde Matrix,它在 xᵢ 都为正数时可以保证永远有唯一解.    因此在实数领域, 我们总能保证上面这个冗余策略很好的工作.  好了, 到此为止我们讨论了EC在实数范围内的全部内容.相信大家根据以上原理很容易写出一个简单但可靠的EC的实现.但这套理论还不能直接应用到线上产品中.因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,通过Vandermonde矩阵生成校验块, 那校验块的数值几乎确定会溢出.下一篇 Erasure-Code-擦除码-2-实现篇 中,我们会展示出算数和计算机算法之间的差异,以及我们将通过什么样的手段来解决这些问题, 将EC真正应用到生产环境中.  敬请关注:      第二篇:实现    第三篇:极限(疯狂编辑中)  ">


  <meta name="author" content="张炎泼(xp)">


<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="OpenACID Blog">
<meta property="og:title" content="Erasure-Code-擦除码-1-原理篇">
<meta property="og:url" content="https://blog.openacid.com/storage/ec-1/">


  <meta property="og:description" content="前言做分布式存储的同学, 一定都知道一个了不地的冗余算法叫作擦除码(Erasure-Code), 它让存储以多副本几分之一的成本来达到同样高的可靠性.虽然web上有很多介绍EC的文字,但几乎所有这些文字都为了严(bi)谨(ge)而搞的像牛津词典一样难读,懂的人不需要看, 不懂的人看不懂.能把事情给人讲明白, 文字才有用.于是准备了这3篇介绍EC的文字, 我敢肯定, 你没看过这样通(di)俗(diao)易(she)懂(hua)的EC教程.看完这3篇文字! 保你可以徒手写出一个EC存储系统, 本文是第一部分:  第一篇:原理  第二篇:实现  第三篇:极限(疯狂编辑中)问题分布式系统的第一个问题是可靠解决了数据可靠性的问题之后,数据的其他问题如一致性, 性能, 可用性等的讨论才有意义.然而现实残酷, 存储的硬件设备总是不够可靠. 下图摘自 backblaze发布的硬盘故障率统计此外, 服务器还会宕机,磁盘会掉,光纤会被挖掘机铲断, 机房会被大雨淹没.因此数据的存储必须要做到在部分硬件故障时还能保证正常读(或读写), 才可以达到工业可用的可靠性.而提高可靠性最直接最简单的方法, 就是 对一份数据存储多个副本(副本数一般选择3).  结合目前经验上的磁盘的损坏率(大约是年损坏率7%),3个副本可以达到一个工业可接受的可靠性,这个可靠性的预期大约是11个9以上(99.999999999%的概率不丢数据).  有些时候为了降低成本, 只存储2个副本, 也可以达到8个9的可靠性.3副本的方式虽然简单容易实现, 但要额外浪费2倍的存储空间,因此存储领域中一直都希望用一种较少的冗余的存储方式, 来实现同样较高的可靠性.不论是单机上的RAID技术, 还是今天要提到的EC(Erasure-Code, 擦除码, 纠删码)都是用来解决这个问题的. 接下来, 我们通过几个例子, 来逐步展示 EC 的工作原理.  RAID 本质上跟EC没有区别, 它是单机系统时代被广泛使用的成熟实现.EC可以认为是分布式系统发展起来后, RAID算法在多机系统上的重新实现:      RAID-0 相当于单副本;    RAID-1 相当于2副本;    RAID-5 相当于EC的k+1模式, k个数据块+1个校验块;    RAID-6 相当于EC的k+2模式, k个数据块+2个校验块;  EC的基本原理EC的目标可以简单的理解为: 对k个同样大小的数据块,额外增加m个校验块,以使得这k+m个数据中任意丢失m个数据块/校验块时都能把丢失的数据找回.栗子1: 实现k+1的冗余策略🌰Q: 有3个自然数, 能否做到再记录第4个数字,让任何一个数字丢失的时候都可以将其找回?这个问题很简单, 记录这3个数字的和:假设3个数字是: d₁, d₂, d₃ ;再存储一个 y₁ = d₁ + d₂ + d₃ 就可以了.于是:      存储过程:    就是存储这4个数字: d₁, d₂, d₃, y₁.        恢复过程:                  如果 d₁, d₂, d₃ 任意一个丢失, 例如 d₁ 丢失了,我们都可以通过 d₁ = y₁ - d₂ - d₃ 来得到 d₁ .                    如果 y₁ 丢失, 则再次取 d₁ + d₂ + d₃ 的和就可以将 y₁ 找回.            这种求和冗余策略, 就是 EC 算法的核心.在上面这个简单的系统中, 总共存储了4份数据, 有效的数据是3份. 冗余是133%,它的可靠性和2副本的200%冗余的存储策略差不多: 最多允许丢失1份数据.            策略      冗余度      可靠性      存储策略示意                  2副本      200%      允许丢1块: 1 X 10⁻⁸      (d₁,d₁), (d₂,d₂), (d₃,d₃)              3+1求和冗余      133%      允许丢1块: 6 X 10⁻⁸      (d₁, d₂, d₃, y₁)        这里还只是差不多, 虽然都是允许丢失1块数据, 但还并不是完全一样,后面详细讨论可靠性的计算.在讨论可靠性的时候, 一般数据丢失风险没有量级的差异, 就可以认为是比较接近的.  上面这个k+1的例子是和我们平时使用的 RAID-5 是类似的.RAID-5 通过对k个(可能是11个左右)数据块求出1份校验和的数据块.存储这份校验块, 并允许1块(数据或校验)丢失后可以找回.  但在工程上, RAID-5 的计算并不是自然数的求和, 而是用bit-AND操作代替加法的. 后面细聊.栗子2: 实现k+2的冗余策略🌰🌰现在我们在k+1的冗余策略基础上, 尝试增加更多的校验块, 来实现任意k+2的冗余策略.Q: 有3块数据:  d₁, d₂, d₃可否另外再存储2个冗余的校验块(共5块), 让整个系统任意丢失2份数据时都能找回?在k+1求和的策略里, 我们给数据块和校验块建立了一个方程, 把它们关联起来了:y₁ = d₁ + d₂ + d₃.现在, 如果要增加可丢失的块数, 简单的把 y₁ 存2次是不够的.  例如我们存储了2个校验块:              存储过程:      存储 d₁, d₂, d₃, y₁, y₂ 这5个数字.              恢复过程:      如果 d₁, d₂ 都丢失了(用 u₁, u₂ 表示丢失的数据),下面这个关于 u₁, u₂ 的线性方程是有无穷多解的:            我们没有办法从这个方程组里解出 u₁, u₂ 的值, 因为第2个方程跟第1个一毛一样,没有提供更多的信息.      所以我们现在需要做的是, 对第2个校验块 y₂, 设计一个新的计算方法, 使之跟3个数据块之间建立一个不同的关联,使得当 d₁, d₂ 丢失时方程组有解:我们采用的方式是, 在计算 y₂  时, 给每个数据 dⱼ 设置不同的系数:  计算 y₁ 时, 对每个数字乘以1, 1, 1, 1 …  计算 y₂ 时, 对每个数字乘以1, 2, 4, 8 …按照此方案, 我们就可以建议一个k+2的存储系统:      存储过程:    存储 d₁, d₂, d₃, y₁, y₂ 这5个数字.        数据恢复:    如果 d₁ 或 d₂ 之一丢失,恢复的过程跟k+1策略一样;    如果 d₁, d₂ 丢失(同样用 u₁, u₂ 表示),我们可以使用剩下的3个数字 d₃, y₁, y₂来建里1个关于 u₁, u₂ 的二元一次方程组:  解出上面这个方程组, 就找回了丢失的 u₁, u₂ .  以上这种加系数计算校验块的方式, 就是RAID-6的基本工作方式:  RAID-6为k个数据块(例如k=10)之外再多存储2个校验数据,当整个系统丢失2块数据时, 都可以找回.  为什么计算 y₂ 的系数是1, 2, 4, 8…? 系数的选择有很多种方法, 1, 2, 4, 8是其中一个.只要保证最终丢失2个数字构成的方程组有唯一解就可以.在k+2的场景中, 选择1, 2, 3, 4…作为系数也可以.到这里我们就得到了k+2的EC的算法:通过166%的冗余, 实现差不多和三副本300%冗余一样的可靠性.栗子3: 实现k+m的冗余策略🌰🌰🌰如果要增加更多的冗余,让EC来实现相当于4副本差不多的可靠性: k+3,我们需要给上面的策略再增加一个校验块 y₃ ,而 y₃ 的计算我们需要再为所有的 dⱼ 选择1组不同的系数,例如1,3,9,27…来保证后面数据丢失时,得到的1个3元一次方程组是可解的:这样我们通过不断的增加不同的系数, 就可以得到任意的k+m的EC冗余存储策略的实现.到此为止, 就是EC算法的核心思想了.接下来, 我们再深入1点, 从另外1个角度来解释下为什么要选择这样1组系数.  现实中使用的RAID-5和RAID-6都是 EC 算法的子集.EC 是更具通用性的算法. 但因为实现的成本(主要是恢复数据时的计算开销), RAID-5 和RAID-6在单机的可靠性实现中还是占主流地位.  但随着存储量的不断增大, 百PB的存储已经不算是很极端场景了.RAID-6 在单机环境下不算高的数据丢失风险在大数据量的场景中显示的越来越明显.于是在云存储(大规模存储)领域, 能支持更多的冗余校验块的EC成为了主流.EC的几何解释上面介绍了如何选择 EC 生成校验块(编码过程)的系数,我们隐约可以感觉到它的系数选择可能有某种内涵,接下来我们回到最初的问题, 思索下为什么要使用这样1组系数.我们从比较简单的情况开始, 看下2个数据块计算(多个)校验块的方法:2+m的冗余的本质: 两点确定一条直线假设 现在我们有2个数据块 d₁, d₂. 要做2个校验块.我们使用1个直线的方程, 把 d₁, d₂ 作为系数, 来实现数据的冗余备份和恢复:这条直线具备这样的特点:  这条直线包含的所有数据块 dⱼ 的信息:          任何1对 d₁, d₂ 的值就确定一条不同的直线.      同样, 任意1条直线也唯一对应1对 d₁, d₂ 的值.      数据可靠性的问题就转化成了:  我们要保存足够多的关于这条直线的信息, 能够在需要的时候找回这条直线.  然后再提取直线方程的系数来找回最初存储的数据块 d₁, d₂.要保存足够多的信息, 最直观的方法就是记录这条直线上的几个点的坐标.  例如假设要存储的数据d₁ d₂ 分别是5, 6, 则直线方程是: y = 5 + 6x.记录直线上x=1, 2 时y的值, 如下图:  因为2点可以确定一条直线, 只要拿到直线上2个点的坐标, 就能确定直线方程,从而确定它的系数 d₁, d₂ .按照这样的思路, 我们重新用直线方程的方式描述数据冗余生成和数据恢复的过程:      存储过程:    以 d₁, d₂ 作为系数建立一个直线方程,再在直线上取2个点,记录点的坐标(这里我们总是取x = [1, 2, 3…]的自然数的值,所以只记录y的值就可以了): d₁, d₂, (1, y₁), (2, y₂).        恢复过程:    已知过直线2点 (1, y₁), (2, y₂) 来确定直线方程, 再提取方程的系数.  在这个校验块跟数据块的关系中:丢失1个数据块时只用 y₁ 的方程就够了.丢失2个数据块时才需要解二元一次方程组. 如果 y₁ 或 y₂ 丢失, 则通过重新取点的方式恢复.  我们可以在直线上取任意多个点, 但恢复时最多也只需要2个点就够了.k+m的冗余的本质: 高次曲线现在我们把它再推广到更一般的情况:直线方程只有2个系数  d₁, d₂ , 只能用于对2块数据做冗余,如果要用描点方式来为更多的数据块生成冗余数据,我们就需要有更多系数的方程, 也就是使用高次的曲线.  例如:二次曲线抛物线 y = a x² + b x + c 需要3个系数来确定(可用来存储3块数据),同时也需要知道抛物线上的3个点的坐标来找回这条抛物线.如果有k个数据块, 我们把k个数据作为系数, 来定义1条关于x的高次曲线,再通过记录曲线上的点的坐标来实现冗余:  例如要存储4个数据1, 2, 3, 4, 则曲线方程是: y = 1 + 2x + 3x² + 4x³.记录曲线上x=1, 2, 3, 4 时y的值, 如下图:        存储过程:    取m个不同的x的值(1, 2, 3…m), 记录这条曲线上m个不同点的坐标:        存储所有k个数据块 d₁, d₂ ....和所有m个校验块 y₁, y₂ ....        恢复过程:    平面上m个点可以唯一确定1条 m-1次幂的曲线(或通过m个点跟k-m个已知系数确定一条k-1次幂的曲线).确定了这条关于x的曲线,就找回了它的系数,也就是数据块      以上就是 EC存储跟恢复的几何本质:一条k-1次曲线可以通过k个系数或曲线上的点来确定.从曲线方程到生成矩阵从EC的几何本质出发, 我们再系统的描述下生成校验块的过程:为x取自然数的值(1,2,3…)来计算 y 的值:把上面等式写成矩阵的形式, 就得到了EC校验块的 生成矩阵 Generator-Matrix:这里 y₁, y₂ ... 就是校验块的数据,因此, 上面栗子3中选择的系数, 就是从这里来的.而这个矩阵, 就是著名的 Vandermonde 矩阵.  Vandermonde 矩阵只是 EC 其中1种系数的选择方式.其他常用的系数矩阵还有 Cauchy 矩阵等.EC的解码: 求解n元一次方程组EC生成校验块的过程称之为EC的编码,也就是用Vandermonde矩阵去乘所有的数据块.而当数据丢失需要找回的时候,使用的是EC的解码过程.既然EC的编码过程是编码矩阵(Vandermonde)和数据块列相乘:那么解码的过程就可以描述如下:假设有q个数字丢失了, q &lt;= m.从上面的编码矩阵中选择q行,组成的一次方程组, 求解方程组算出丢失的数据.例如 d₂, d₃ 丢失了, 下面用 u₂, u₃ 表示(只丢失了2块数据, 不需要所有的m个校验块参与, 只需要2个校验块来恢复数据)这个矩阵表示的方程组里有2个未知数 u₂, u₃ ,解方程即可得到 u₂, u₃ 这2块丢失的数据.Vandermonde 矩阵保证方程组有解对于k+m的EC来说, 任意丢失m个数据块都可以将其找回.因为我们选择的Vandermonde 矩阵保证了任意m行m列组成的子矩阵都是线性无关的,构成的方程肯定有确定解. 例如:      Vandermonde 的 行列式的值为:        只要 xᵢ 都不同, 则 Vandermonde 矩阵的行列式就不为0, 矩阵可逆, 表示方程有唯一解.        Vandermonde 矩阵的任意 m x m 的子矩阵, 是一个Generalized Vandermonde Matrix,它在 xᵢ 都为正数时可以保证永远有唯一解.    因此在实数领域, 我们总能保证上面这个冗余策略很好的工作.  好了, 到此为止我们讨论了EC在实数范围内的全部内容.相信大家根据以上原理很容易写出一个简单但可靠的EC的实现.但这套理论还不能直接应用到线上产品中.因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,通过Vandermonde矩阵生成校验块, 那校验块的数值几乎确定会溢出.下一篇 Erasure-Code-擦除码-2-实现篇 中,我们会展示出算数和计算机算法之间的差异,以及我们将通过什么样的手段来解决这些问题, 将EC真正应用到生产环境中.  敬请关注:      第二篇:实现    第三篇:极限(疯狂编辑中)  ">







  <meta property="article:published_time" content="2020-01-28T00:00:00+08:00">





  

  


<link rel="canonical" href="https://blog.openacid.com/storage/ec-1/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "OpenACID-分布式研究小院",
      "url": "https://blog.openacid.com/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="OpenACID Blog Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="apple-touch-icon" sizes="180x180"    href="/assets/images/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
<link rel="manifest"                            href="/assets/images/favicon/site.webmanifest">

<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li>[Skip to primary navigation]</li>
    <li>[Skip to content]</li>
    <li>[Skip to footer]</li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please [upgrade your browser] to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo/icon-lemon-margin.png" alt=""></a>
        
        <a class="site-title" href="/">
          OpenACID Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              [About Us]
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">
  
  
  <p>

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author/xp.jpg" alt="张炎泼(xp)" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">张炎泼(xp)</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>正在学画画, 主业是码农</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li>[<i class="fas fa-fw fa-link" aria-hidden="true"></i> 个人博客]</li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      
        <li>
          [
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          ]
        </li>
      

      

      

      

      

      

      

      

      

      

      
        <li>
          [
            <i class="fab fa-fw fa-weibo" aria-hidden="true"></i> Weibo
          ]
        </li>
      

      

      

      

      <!--
  <li>
    [
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    ]
  </li>
-->
    </ul>
  </div>

  </p>
  
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Erasure-Code-擦除码-1-原理篇">
    <meta itemprop="description" content="前言做分布式存储的同学, 一定都知道一个了不地的冗余算法叫作擦除码(Erasure-Code), 它让存储以多副本几分之一的成本来达到同样高的可靠性.虽然web上有很多介绍EC的文字,但几乎所有这些文字都为了严(bi)谨(ge)而搞的像牛津词典一样难读,懂的人不需要看, 不懂的人看不懂.能把事情给人讲明白, 文字才有用.于是准备了这3篇介绍EC的文字, 我敢肯定, 你没看过这样通(di)俗(diao)易(she)懂(hua)的EC教程.看完这3篇文字! 保你可以徒手写出一个EC存储系统, 本文是第一部分:  第一篇:原理  第二篇:实现  第三篇:极限(疯狂编辑中)问题分布式系统的第一个问题是可靠解决了数据可靠性的问题之后,数据的其他问题如一致性, 性能, 可用性等的讨论才有意义.然而现实残酷, 存储的硬件设备总是不够可靠. 下图摘自 backblaze发布的硬盘故障率统计此外, 服务器还会宕机,磁盘会掉,光纤会被挖掘机铲断, 机房会被大雨淹没.因此数据的存储必须要做到在部分硬件故障时还能保证正常读(或读写), 才可以达到工业可用的可靠性.而提高可靠性最直接最简单的方法, 就是 对一份数据存储多个副本(副本数一般选择3).  结合目前经验上的磁盘的损坏率(大约是年损坏率7%),3个副本可以达到一个工业可接受的可靠性,这个可靠性的预期大约是11个9以上(99.999999999%的概率不丢数据).  有些时候为了降低成本, 只存储2个副本, 也可以达到8个9的可靠性.3副本的方式虽然简单容易实现, 但要额外浪费2倍的存储空间,因此存储领域中一直都希望用一种较少的冗余的存储方式, 来实现同样较高的可靠性.不论是单机上的RAID技术, 还是今天要提到的EC(Erasure-Code, 擦除码, 纠删码)都是用来解决这个问题的. 接下来, 我们通过几个例子, 来逐步展示 EC 的工作原理.  RAID 本质上跟EC没有区别, 它是单机系统时代被广泛使用的成熟实现.EC可以认为是分布式系统发展起来后, RAID算法在多机系统上的重新实现:      RAID-0 相当于单副本;    RAID-1 相当于2副本;    RAID-5 相当于EC的k+1模式, k个数据块+1个校验块;    RAID-6 相当于EC的k+2模式, k个数据块+2个校验块;  EC的基本原理EC的目标可以简单的理解为: 对k个同样大小的数据块,额外增加m个校验块,以使得这k+m个数据中任意丢失m个数据块/校验块时都能把丢失的数据找回.栗子1: 实现k+1的冗余策略🌰Q: 有3个自然数, 能否做到再记录第4个数字,让任何一个数字丢失的时候都可以将其找回?这个问题很简单, 记录这3个数字的和:假设3个数字是: d₁, d₂, d₃ ;再存储一个 y₁ = d₁ + d₂ + d₃ 就可以了.于是:      存储过程:    就是存储这4个数字: d₁, d₂, d₃, y₁.        恢复过程:                  如果 d₁, d₂, d₃ 任意一个丢失, 例如 d₁ 丢失了,我们都可以通过 d₁ = y₁ - d₂ - d₃ 来得到 d₁ .                    如果 y₁ 丢失, 则再次取 d₁ + d₂ + d₃ 的和就可以将 y₁ 找回.            这种求和冗余策略, 就是 EC 算法的核心.在上面这个简单的系统中, 总共存储了4份数据, 有效的数据是3份. 冗余是133%,它的可靠性和2副本的200%冗余的存储策略差不多: 最多允许丢失1份数据.            策略      冗余度      可靠性      存储策略示意                  2副本      200%      允许丢1块: 1 X 10⁻⁸      (d₁,d₁), (d₂,d₂), (d₃,d₃)              3+1求和冗余      133%      允许丢1块: 6 X 10⁻⁸      (d₁, d₂, d₃, y₁)        这里还只是差不多, 虽然都是允许丢失1块数据, 但还并不是完全一样,后面详细讨论可靠性的计算.在讨论可靠性的时候, 一般数据丢失风险没有量级的差异, 就可以认为是比较接近的.  上面这个k+1的例子是和我们平时使用的 RAID-5 是类似的.RAID-5 通过对k个(可能是11个左右)数据块求出1份校验和的数据块.存储这份校验块, 并允许1块(数据或校验)丢失后可以找回.  但在工程上, RAID-5 的计算并不是自然数的求和, 而是用bit-AND操作代替加法的. 后面细聊.栗子2: 实现k+2的冗余策略🌰🌰现在我们在k+1的冗余策略基础上, 尝试增加更多的校验块, 来实现任意k+2的冗余策略.Q: 有3块数据:  d₁, d₂, d₃可否另外再存储2个冗余的校验块(共5块), 让整个系统任意丢失2份数据时都能找回?在k+1求和的策略里, 我们给数据块和校验块建立了一个方程, 把它们关联起来了:y₁ = d₁ + d₂ + d₃.现在, 如果要增加可丢失的块数, 简单的把 y₁ 存2次是不够的.  例如我们存储了2个校验块:              存储过程:      存储 d₁, d₂, d₃, y₁, y₂ 这5个数字.              恢复过程:      如果 d₁, d₂ 都丢失了(用 u₁, u₂ 表示丢失的数据),下面这个关于 u₁, u₂ 的线性方程是有无穷多解的:            我们没有办法从这个方程组里解出 u₁, u₂ 的值, 因为第2个方程跟第1个一毛一样,没有提供更多的信息.      所以我们现在需要做的是, 对第2个校验块 y₂, 设计一个新的计算方法, 使之跟3个数据块之间建立一个不同的关联,使得当 d₁, d₂ 丢失时方程组有解:我们采用的方式是, 在计算 y₂  时, 给每个数据 dⱼ 设置不同的系数:  计算 y₁ 时, 对每个数字乘以1, 1, 1, 1 …  计算 y₂ 时, 对每个数字乘以1, 2, 4, 8 …按照此方案, 我们就可以建议一个k+2的存储系统:      存储过程:    存储 d₁, d₂, d₃, y₁, y₂ 这5个数字.        数据恢复:    如果 d₁ 或 d₂ 之一丢失,恢复的过程跟k+1策略一样;    如果 d₁, d₂ 丢失(同样用 u₁, u₂ 表示),我们可以使用剩下的3个数字 d₃, y₁, y₂来建里1个关于 u₁, u₂ 的二元一次方程组:  解出上面这个方程组, 就找回了丢失的 u₁, u₂ .  以上这种加系数计算校验块的方式, 就是RAID-6的基本工作方式:  RAID-6为k个数据块(例如k=10)之外再多存储2个校验数据,当整个系统丢失2块数据时, 都可以找回.  为什么计算 y₂ 的系数是1, 2, 4, 8…? 系数的选择有很多种方法, 1, 2, 4, 8是其中一个.只要保证最终丢失2个数字构成的方程组有唯一解就可以.在k+2的场景中, 选择1, 2, 3, 4…作为系数也可以.到这里我们就得到了k+2的EC的算法:通过166%的冗余, 实现差不多和三副本300%冗余一样的可靠性.栗子3: 实现k+m的冗余策略🌰🌰🌰如果要增加更多的冗余,让EC来实现相当于4副本差不多的可靠性: k+3,我们需要给上面的策略再增加一个校验块 y₃ ,而 y₃ 的计算我们需要再为所有的 dⱼ 选择1组不同的系数,例如1,3,9,27…来保证后面数据丢失时,得到的1个3元一次方程组是可解的:这样我们通过不断的增加不同的系数, 就可以得到任意的k+m的EC冗余存储策略的实现.到此为止, 就是EC算法的核心思想了.接下来, 我们再深入1点, 从另外1个角度来解释下为什么要选择这样1组系数.  现实中使用的RAID-5和RAID-6都是 EC 算法的子集.EC 是更具通用性的算法. 但因为实现的成本(主要是恢复数据时的计算开销), RAID-5 和RAID-6在单机的可靠性实现中还是占主流地位.  但随着存储量的不断增大, 百PB的存储已经不算是很极端场景了.RAID-6 在单机环境下不算高的数据丢失风险在大数据量的场景中显示的越来越明显.于是在云存储(大规模存储)领域, 能支持更多的冗余校验块的EC成为了主流.EC的几何解释上面介绍了如何选择 EC 生成校验块(编码过程)的系数,我们隐约可以感觉到它的系数选择可能有某种内涵,接下来我们回到最初的问题, 思索下为什么要使用这样1组系数.我们从比较简单的情况开始, 看下2个数据块计算(多个)校验块的方法:2+m的冗余的本质: 两点确定一条直线假设 现在我们有2个数据块 d₁, d₂. 要做2个校验块.我们使用1个直线的方程, 把 d₁, d₂ 作为系数, 来实现数据的冗余备份和恢复:这条直线具备这样的特点:  这条直线包含的所有数据块 dⱼ 的信息:          任何1对 d₁, d₂ 的值就确定一条不同的直线.      同样, 任意1条直线也唯一对应1对 d₁, d₂ 的值.      数据可靠性的问题就转化成了:  我们要保存足够多的关于这条直线的信息, 能够在需要的时候找回这条直线.  然后再提取直线方程的系数来找回最初存储的数据块 d₁, d₂.要保存足够多的信息, 最直观的方法就是记录这条直线上的几个点的坐标.  例如假设要存储的数据d₁ d₂ 分别是5, 6, 则直线方程是: y = 5 + 6x.记录直线上x=1, 2 时y的值, 如下图:  因为2点可以确定一条直线, 只要拿到直线上2个点的坐标, 就能确定直线方程,从而确定它的系数 d₁, d₂ .按照这样的思路, 我们重新用直线方程的方式描述数据冗余生成和数据恢复的过程:      存储过程:    以 d₁, d₂ 作为系数建立一个直线方程,再在直线上取2个点,记录点的坐标(这里我们总是取x = [1, 2, 3…]的自然数的值,所以只记录y的值就可以了): d₁, d₂, (1, y₁), (2, y₂).        恢复过程:    已知过直线2点 (1, y₁), (2, y₂) 来确定直线方程, 再提取方程的系数.  在这个校验块跟数据块的关系中:丢失1个数据块时只用 y₁ 的方程就够了.丢失2个数据块时才需要解二元一次方程组. 如果 y₁ 或 y₂ 丢失, 则通过重新取点的方式恢复.  我们可以在直线上取任意多个点, 但恢复时最多也只需要2个点就够了.k+m的冗余的本质: 高次曲线现在我们把它再推广到更一般的情况:直线方程只有2个系数  d₁, d₂ , 只能用于对2块数据做冗余,如果要用描点方式来为更多的数据块生成冗余数据,我们就需要有更多系数的方程, 也就是使用高次的曲线.  例如:二次曲线抛物线 y = a x² + b x + c 需要3个系数来确定(可用来存储3块数据),同时也需要知道抛物线上的3个点的坐标来找回这条抛物线.如果有k个数据块, 我们把k个数据作为系数, 来定义1条关于x的高次曲线,再通过记录曲线上的点的坐标来实现冗余:  例如要存储4个数据1, 2, 3, 4, 则曲线方程是: y = 1 + 2x + 3x² + 4x³.记录曲线上x=1, 2, 3, 4 时y的值, 如下图:        存储过程:    取m个不同的x的值(1, 2, 3…m), 记录这条曲线上m个不同点的坐标:        存储所有k个数据块 d₁, d₂ ....和所有m个校验块 y₁, y₂ ....        恢复过程:    平面上m个点可以唯一确定1条 m-1次幂的曲线(或通过m个点跟k-m个已知系数确定一条k-1次幂的曲线).确定了这条关于x的曲线,就找回了它的系数,也就是数据块      以上就是 EC存储跟恢复的几何本质:一条k-1次曲线可以通过k个系数或曲线上的点来确定.从曲线方程到生成矩阵从EC的几何本质出发, 我们再系统的描述下生成校验块的过程:为x取自然数的值(1,2,3…)来计算 y 的值:把上面等式写成矩阵的形式, 就得到了EC校验块的 生成矩阵 Generator-Matrix:这里 y₁, y₂ ... 就是校验块的数据,因此, 上面栗子3中选择的系数, 就是从这里来的.而这个矩阵, 就是著名的 Vandermonde 矩阵.  Vandermonde 矩阵只是 EC 其中1种系数的选择方式.其他常用的系数矩阵还有 Cauchy 矩阵等.EC的解码: 求解n元一次方程组EC生成校验块的过程称之为EC的编码,也就是用Vandermonde矩阵去乘所有的数据块.而当数据丢失需要找回的时候,使用的是EC的解码过程.既然EC的编码过程是编码矩阵(Vandermonde)和数据块列相乘:那么解码的过程就可以描述如下:假设有q个数字丢失了, q &lt;= m.从上面的编码矩阵中选择q行,组成的一次方程组, 求解方程组算出丢失的数据.例如 d₂, d₃ 丢失了, 下面用 u₂, u₃ 表示(只丢失了2块数据, 不需要所有的m个校验块参与, 只需要2个校验块来恢复数据)这个矩阵表示的方程组里有2个未知数 u₂, u₃ ,解方程即可得到 u₂, u₃ 这2块丢失的数据.Vandermonde 矩阵保证方程组有解对于k+m的EC来说, 任意丢失m个数据块都可以将其找回.因为我们选择的Vandermonde 矩阵保证了任意m行m列组成的子矩阵都是线性无关的,构成的方程肯定有确定解. 例如:      Vandermonde 的 行列式的值为:        只要 xᵢ 都不同, 则 Vandermonde 矩阵的行列式就不为0, 矩阵可逆, 表示方程有唯一解.        Vandermonde 矩阵的任意 m x m 的子矩阵, 是一个Generalized Vandermonde Matrix,它在 xᵢ 都为正数时可以保证永远有唯一解.    因此在实数领域, 我们总能保证上面这个冗余策略很好的工作.  好了, 到此为止我们讨论了EC在实数范围内的全部内容.相信大家根据以上原理很容易写出一个简单但可靠的EC的实现.但这套理论还不能直接应用到线上产品中.因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,通过Vandermonde矩阵生成校验块, 那校验块的数值几乎确定会溢出.下一篇 Erasure-Code-擦除码-2-实现篇 中,我们会展示出算数和计算机算法之间的差异,以及我们将通过什么样的手段来解决这些问题, 将EC真正应用到生产环境中.  敬请关注:      第二篇:实现    第三篇:极限(疯狂编辑中)  ">
    <meta itemprop="datePublished" content="January 28, 2020">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Erasure-Code-擦除码-1-原理篇
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  13 分钟阅读

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> 本文目录</h4></header>
              <ul class="toc__menu">
  <li>[前言]</li>
  <li>[问题]</li>
  <li>[EC的基本原理]
    <ul>
      <li>[栗子1: 实现k+1的冗余策略]</li>
      <li>[栗子2: 实现k+2的冗余策略]</li>
      <li>[栗子3: 实现k+m的冗余策略]</li>
    </ul>
  </li>
  <li>[EC的几何解释]
    <ul>
      <li>[2+m的冗余的本质: 两点确定一条直线]</li>
      <li>[k+m的冗余的本质: 高次曲线]</li>
      <li>[从曲线方程到生成矩阵]</li>
    </ul>
  </li>
  <li>[EC的解码: 求解n元一次方程组]
    <ul>
      <li>[Vandermonde 矩阵保证方程组有解]</li>
    </ul>
  </li>
</ul>
            </nav>
          </aside>
        
        <p style="font-size: 0.7rem; font-weight: bolder;">
本文链接: [https://blog.openacid.com/storage/ec-1/]


<br/>
下载pdf: [Erasure-Code-擦除码-1-原理篇.pdf]

</p>


        
          



<img src="/post-res/ec-1/ec-1-banner.png" alt="Erasure-Code-擦除码-1-原理篇" class="page__hero-image">

        

        <h1 id="前言">前言</h1>

<p>做分布式存储的同学, 一定都知道一个了不地的冗余算法叫作擦除码([Erasure-Code]), 
它让存储以多副本<strong>几分之一</strong>的成本来达到同样高的可靠性.</p>

<p>虽然web上有很多介绍EC的文字,
但几乎所有这些文字都为了严(bi)谨(ge)而搞的像牛津词典一样难读,
懂的人不需要看, 不懂的人看不懂.</p>

<p>能把事情给人讲明白, 文字才有用.
于是准备了这3篇介绍EC的文字, 我敢肯定, 你没看过这样<strong>通(di)俗(diao)易(she)懂(hua)</strong>的EC教程.
看完这3篇文字! 保你可以徒手写出一个EC存储系统, 本文是第一部分:</p>

<ul>
  <li>[第一篇:原理]</li>
  <li>[第二篇:实现]</li>
  <li>第三篇:极限(疯狂编辑中)</li>
</ul>

<h1 id="问题">问题</h1>

<p><strong>分布式系统的第一个问题是可靠</strong></p>

<p>解决了数据可靠性的问题之后,
数据的其他问题如<strong>一致性</strong>, <strong>性能</strong>, <strong>可用性</strong>等的讨论才有意义.</p>

<p>然而现实残酷, 存储的硬件设备总是不够可靠. 下图摘自 [backblaze发布的硬盘故障率统计]</p>

<p><img src="/post-res/ec-1/drive-stats-2016-q1-failure-by-mfg.jpg" alt="" /></p>

<p>此外, 服务器还会宕机,磁盘会掉,光纤会被挖掘机铲断, 机房会被大雨淹没.
因此数据的存储必须要做到在部分硬件故障时还能保证正常读(或读写), 才可以达到工业可用的可靠性.</p>

<p>而提高可靠性最直接最简单的方法, 就是 <strong>对一份数据存储多个副本</strong>
(副本数一般选择3).</p>

<blockquote>
  <p>结合目前经验上的磁盘的损坏率(大约是年损坏率7%),
3个副本可以达到一个工业可接受的可靠性,
这个可靠性的预期大约是11个9以上(99.999999999%的概率不丢数据).</p>

  <p>有些时候为了降低成本, 只存储2个副本, 也可以达到8个9的可靠性.</p>
</blockquote>

<p>3副本的方式虽然简单容易实现, 但要额外浪费2倍的存储空间,
因此存储领域中一直都希望用一种较少的冗余的存储方式, 来实现同样较高的可靠性.</p>

<p>不论是单机上的[RAID]技术, 还是今天要提到的EC([Erasure-Code], 擦除码, 纠删码)
都是用来解决这个问题的. 接下来, 我们通过几个例子, 来逐步展示 EC 的工作原理.</p>

<blockquote>
  <p>RAID 本质上跟EC没有区别, 它是单机系统时代被广泛使用的成熟实现.
EC可以认为是分布式系统发展起来后, RAID算法在多机系统上的重新实现:</p>

  <ul>
    <li>RAID-0 相当于单副本;</li>
    <li>RAID-1 相当于2副本;</li>
    <li>RAID-5 相当于EC的k+1模式, k个数据块+1个校验块;</li>
    <li>RAID-6 相当于EC的k+2模式, k个数据块+2个校验块;</li>
  </ul>
</blockquote>

<h1 id="ec的基本原理">EC的基本原理</h1>

<p>EC的目标可以简单的理解为: 对k个同样大小的数据块,
额外增加m个校验块,
以使得这k+m个数据中任意丢失m个数据块/校验块时都能把丢失的数据找回.</p>

<h2 id="栗子1-实现k1的冗余策略">栗子1: 实现k+1的冗余策略</h2>

<p>🌰</p>

<p><strong>Q: 有3个自然数, 能否做到再记录第4个数字,
让任何一个数字丢失的时候都可以将其找回</strong>?</p>

<p>这个问题很简单, 记录这3个数字的和:
假设3个数字是: <code class="highlighter-rouge">d₁, d₂, d₃</code> ;
再存储一个 <code class="highlighter-rouge">y₁ = d₁ + d₂ + d₃</code> 就可以了.</p>

<p>于是:</p>

<ul>
  <li>
    <p>存储过程:</p>

    <p>就是存储这4个数字: <code class="highlighter-rouge">d₁, d₂, d₃, y₁</code>.</p>
  </li>
  <li>
    <p>恢复过程:</p>

    <ul>
      <li>
        <p>如果 <code class="highlighter-rouge">d₁, d₂, d₃</code> 任意一个丢失, 例如 <code class="highlighter-rouge">d₁</code> 丢失了,
我们都可以通过 <code class="highlighter-rouge">d₁ = y₁ - d₂ - d₃</code> 来得到 <code class="highlighter-rouge">d₁</code> .</p>
      </li>
      <li>
        <p>如果 <code class="highlighter-rouge">y₁</code> 丢失, 则再次取 <code class="highlighter-rouge">d₁ + d₂ + d₃</code> 的和就可以将 <code class="highlighter-rouge">y₁</code> 找回.</p>
      </li>
    </ul>
  </li>
</ul>

<p>这种<strong>求和冗余</strong>策略, 就是 EC 算法的核心.</p>

<p>在上面这个简单的系统中, 总共存储了4份数据, 有效的数据是3份. 冗余是<strong>133%</strong>,
它的可靠性和2副本的<strong>200%</strong>冗余的存储策略<strong>差不多</strong>: 最多允许丢失1份数据.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">策略</th>
      <th style="text-align: left">冗余度</th>
      <th style="text-align: left">可靠性</th>
      <th style="text-align: left">存储策略示意</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">2副本</td>
      <td style="text-align: left">200%</td>
      <td style="text-align: left">允许丢1块: 1 X 10⁻⁸</td>
      <td style="text-align: left">(d₁,d₁), (d₂,d₂), (d₃,d₃)</td>
    </tr>
    <tr>
      <td style="text-align: left">3+1求和冗余</td>
      <td style="text-align: left">133%</td>
      <td style="text-align: left">允许丢1块: 6 X 10⁻⁸</td>
      <td style="text-align: left">(d₁, d₂, d₃, y₁)</td>
    </tr>
  </tbody>
</table>

<blockquote>
  <p>这里还只是<strong>差不多</strong>, 虽然都是允许丢失1块数据, 但还并不是完全一样,
后面详细讨论可靠性的计算.
在讨论可靠性的时候, 一般数据丢失风险没有量级的差异, 就可以认为是比较接近的.</p>
</blockquote>

<blockquote>
  <p>上面这个k+1的例子是和我们平时使用的 [RAID-5] 是类似的.
[RAID-5] 通过对k个(可能是11个左右)数据块求出1份<strong>校验和</strong>的数据块.
存储这份校验块, 并允许1块(数据或校验)丢失后可以找回.</p>

  <p>但在工程上, [RAID-5] 的计算并不是自然数的求和, 而是用bit-AND操作代替加法的. 后面细聊.</p>
</blockquote>

<h2 id="栗子2-实现k2的冗余策略">栗子2: 实现k+2的冗余策略</h2>

<p>🌰🌰</p>

<p>现在我们在k+1的冗余策略基础上, 尝试增加更多的校验块, 来实现任意k+2的冗余策略.</p>

<p><strong>Q: 有3块数据:  <code class="highlighter-rouge">d₁, d₂, d₃</code>
可否另外再存储2个冗余的校验块(共5块), 让整个系统任意丢失2份数据时都能找回</strong>?</p>

<p>在<strong>k+1求和</strong>的策略里, 我们给数据块和校验块建立了一个方程, 把它们关联起来了:
<code class="highlighter-rouge">y₁ = d₁ + d₂ + d₃</code>.</p>

<p>现在, 如果要增加可丢失的块数, 简单的把 <code class="highlighter-rouge">y₁</code> 存2次是<strong>不够的</strong>.</p>

<blockquote>
  <p>例如我们存储了2个校验块:</p>

  <img src="/publish/wechat/storage/ec-1/images/begin_cases_d_1_d_2_d_3_=_y_1_d_1_d_2_d_3_=_y_2_end_cases_-c8e96d126ec9f242cbffeb94267d03f4.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{cases}
d_1 + d_2 + d_3 = y_1 \\
d_1 + d_2 + d_3 = y_2
\end{cases}"/>

  <ul>
    <li>
      <p>存储过程:</p>

      <p>存储 <code class="highlighter-rouge">d₁, d₂, d₃, y₁, y₂</code> 这5个数字.</p>
    </li>
    <li>
      <p>恢复过程:</p>

      <p>如果 <code class="highlighter-rouge">d₁</code>, <code class="highlighter-rouge">d₂</code> 都丢失了(用 <code class="highlighter-rouge">u₁</code>, <code class="highlighter-rouge">u₂</code> 表示丢失的数据),
下面这个关于 u₁, u₂ 的线性方程是有无穷多解的:</p>

      <img src="/publish/wechat/storage/ec-1/images/begin_cases_u_1_u_2_=_y_1_-_d_3_u_1_u_2_=_y_2_-_d_3_end_cases_-d71d949b529bdfd2f06226eb994ef3e6.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{cases}
u_1 + u_2 = y_1 - d_3 \\
u_1 + u_2 = y_2 - d_3
\end{cases}"/>

      <p>我们没有办法从这个方程组里解出 <code class="highlighter-rouge">u₁</code>, <code class="highlighter-rouge">u₂</code> 的值, 因为第2个方程跟第1个一毛一样,
没有提供更多的信息.</p>
    </li>
  </ul>

</blockquote>

<p>所以我们现在需要做的是, 对第2个校验块 <code class="highlighter-rouge">y₂</code>, 设计一个新的计算方法, 使之跟3个数据块之间建立一个<strong>不同</strong>的关联,
<strong>使得当 <code class="highlighter-rouge">d₁, d₂</code> 丢失时方程组有解</strong>:</p>

<p>我们采用的方式是, 在计算 <code class="highlighter-rouge">y₂</code>  时, 给每个数据 <code class="highlighter-rouge">dⱼ</code> 设置不同的系数:</p>
<ul>
  <li>计算 <code class="highlighter-rouge">y₁</code> 时, 对每个数字乘以1, 1, 1, 1 …</li>
  <li>计算 <code class="highlighter-rouge">y₂</code> 时, 对每个数字乘以1, 2, 4, 8 …</li>
</ul>

<img src="/publish/wechat/storage/ec-1/images/CDATA_begin_aligned_y_1_=_d_1_d_2_d_3_y_2_=_d_1_2_d_2_4_d_3_end-f9f2c37f86d4e35d7ced96d74c32032e.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
y_1 & = d_1 +   d_2 +   d_3 \\
y_2 & = d_1 + 2 d_2 + 4 d_3
\end{aligned} %]]>"/>

<p>按照此方案, 我们就可以建议一个k+2的存储系统:</p>

<ul>
  <li>
    <p>存储过程:</p>

    <p>存储 <code class="highlighter-rouge">d₁, d₂, d₃, y₁, y₂</code> 这5个数字.</p>
  </li>
  <li>
    <p>数据恢复:</p>

    <p>如果 <code class="highlighter-rouge">d₁</code> 或 <code class="highlighter-rouge">d₂</code> 之一丢失,恢复的过程跟k+1策略一样;</p>

    <p>如果 <code class="highlighter-rouge">d₁, d₂</code> 丢失(同样用 <code class="highlighter-rouge">u₁, u₂</code> 表示),
我们可以使用剩下的3个数字 <code class="highlighter-rouge">d₃, y₁, y₂</code>
来建里1个关于 <code class="highlighter-rouge">u₁, u₂</code> 的二元一次方程组:</p>
  </li>
</ul>

<img src="/publish/wechat/storage/ec-1/images/CDATA_begin_cases_begin_aligned_u_1_u_2_=_y_1_-_d_3_u_1_2_u_2_=-e4fc4261b119c56dc137422c41fcc43b.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{cases}
\begin{aligned}
u_1 + u_2   & = y_1 - d_3 \\
u_1 + 2 u_2 & = y_2 - 4 d_3
\end{aligned}
\end{cases} %]]>"/>

<p>解出上面这个方程组, 就找回了丢失的 <code class="highlighter-rouge">u₁, u₂</code> .</p>

<blockquote>
  <p>以上这种<strong>加系数</strong>计算校验块的方式, 就是[RAID-6]的基本工作方式:</p>

  <p>[RAID-6]为k个数据块(例如k=10)之外再多存储2个校验数据,
当整个系统丢失2块数据时, 都可以找回.</p>
</blockquote>

<blockquote>
  <p>为什么计算 <code class="highlighter-rouge">y₂</code> 的系数是1, 2, 4, 8…? 系数的选择有很多种方法, 1, 2, 4, 8是其中一个.
只要保证最终丢失2个数字构成的方程组有唯一解就可以.
在k+2的场景中, 选择1, 2, 3, 4…作为系数也可以.</p>
</blockquote>

<p>到这里我们就得到了k+2的EC的算法:
通过166%的冗余, 实现<strong>差不多</strong>和三副本300%冗余一样的可靠性.</p>

<h2 id="栗子3-实现km的冗余策略">栗子3: 实现k+m的冗余策略</h2>

<p>🌰🌰🌰</p>

<p>如果要增加更多的冗余,让EC来实现相当于4副本差不多的可靠性: k+3,
我们需要给上面的策略再增加一个校验块 <code class="highlighter-rouge">y₃</code> ,</p>

<p>而 <code class="highlighter-rouge">y₃</code> 的计算我们需要再为所有的 <code class="highlighter-rouge">dⱼ</code> 选择1组不同的系数,
例如1,3,9,27…来保证后面数据丢失时,得到的1个3元一次方程组是可解的:</p>

<img src="/publish/wechat/storage/ec-1/images/CDATA_begin_cases_begin_aligned_d_1_d_2_d_3_=_y_1_d_1_2_d_2_4_d-5a75044249e1fdf3a1a678f05365e5bf.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{cases}
\begin{aligned}
d_1 +   d_2 +   d_3 & = y_1 \\
d_1 + 2 d_2 + 4 d_3 & = y_2 \\
d_1 + 3 d_2 + 9 d_3 & = y_2
\end{aligned}
\end{cases} %]]>"/>

<p>这样我们通过不断的增加不同的系数, 就可以得到任意的k+m的EC冗余存储策略的实现.</p>

<p>到此为止, 就是EC算法的核心思想了.
接下来, 我们再深入1点, 从另外1个角度来解释下为什么要选择这样1组系数.</p>

<blockquote>
  <p>现实中使用的[RAID-5]和[RAID-6]都是 EC 算法的子集.
EC 是更具通用性的算法. 但因为实现的成本(主要是恢复数据时的计算开销), [RAID-5] 和
[RAID-6]在单机的可靠性实现中还是占主流地位.</p>

  <p>但随着存储量的不断增大, 百PB的存储已经不算是很极端场景了.
[RAID-6] 在单机环境下不算高的数据丢失风险在大数据量的场景中显示的越来越明显.
于是在云存储(大规模存储)领域, 能支持更多的冗余校验块的EC成为了主流.</p>
</blockquote>

<h1 id="ec的几何解释">EC的几何解释</h1>

<p>上面介绍了如何选择 EC 生成校验块(编码过程)的系数,
我们隐约可以感觉到它的系数选择可能有某种内涵,
接下来我们回到最初的问题, 思索下为什么要使用这样1组系数.</p>

<p>我们从比较简单的情况开始, 看下2个数据块计算(多个)校验块的方法:</p>

<h2 id="2m的冗余的本质-两点确定一条直线">2+m的冗余的本质: 两点确定一条直线</h2>

<p>假设 现在我们有2个数据块 <code class="highlighter-rouge">d₁, d₂</code>. 要做2个校验块.</p>

<p><strong>我们使用1个直线的方程, 把 <code class="highlighter-rouge">d₁, d₂</code> 作为系数, 来实现数据的冗余备份和恢复</strong>:</p>

<img src="/publish/wechat/storage/ec-1/images/y_=_d_1_d_2_x-5157da5e8eb4b4838449f29807eebe10.png" style="display: block; margin: 0 auto 1.3em auto" _alt="y = d_1 + d_2 x"/>

<p>这条直线具备这样的特点:</p>

<ul>
  <li><strong>这条直线包含的所有数据块 <code class="highlighter-rouge">dⱼ</code> 的信息</strong>:
    <ul>
      <li>任何1对 <code class="highlighter-rouge">d₁, d₂</code> 的值就确定一条不同的直线.</li>
      <li>同样, 任意1条直线也唯一对应1对 <code class="highlighter-rouge">d₁, d₂</code> 的值.</li>
    </ul>
  </li>
</ul>

<p>数据可靠性的问题就转化成了:</p>

<ul>
  <li><strong>我们要保存足够多的关于这条直线的信息, 能够在需要的时候找回这条直线.  然后再提取直线方程的系数来找回最初存储的数据块</strong> <code class="highlighter-rouge">d₁, d₂</code>.</li>
</ul>

<p>要保存足够多的信息, <strong>最直观的方法就是记录这条直线上的几个点的坐标</strong>.</p>

<blockquote>
  <p>例如假设要存储的数据<code class="highlighter-rouge">d₁ d₂</code> 分别是5, 6, 则直线方程是: <code class="highlighter-rouge">y = 5 + 6x</code>.
记录直线上<code class="highlighter-rouge">x=1, 2</code> 时y的值, 如下图:</p>

  <p><img src="/post-res/ec-1/y-5-6x-pad.png" alt="y=5+6x" /></p>
</blockquote>

<p>因为2点可以确定一条直线, 只要拿到直线上2个点的坐标, 就能确定直线方程,
从而确定它的系数 <code class="highlighter-rouge">d₁, d₂</code> .
按照这样的思路, 我们重新用直线方程的方式描述数据冗余生成和数据恢复的过程:</p>

<ul>
  <li>
    <p>存储过程:</p>

    <p>以 <code class="highlighter-rouge">d₁, d₂</code> 作为系数建立一个直线方程,
再在直线上取2个点,
记录点的坐标(这里我们总是取x = [1, 2, 3…]的自然数的值,
所以只记录y的值就可以了): <code class="highlighter-rouge">d₁, d₂, (1, y₁), (2, y₂)</code>.</p>
  </li>
  <li>
    <p>恢复过程:</p>

    <p>已知过直线2点 <code class="highlighter-rouge">(1, y₁), (2, y₂)</code> 来确定直线方程, 再提取方程的系数.</p>
  </li>
</ul>

<p>在这个校验块跟数据块的关系中:</p>

<img src="/publish/wechat/storage/ec-1/images/begin_cases_y_1_=_d_1_d_2_y_2_=_d_1_2d_2_end_cases_-d1bcc5cb2e39db26602ccae8c9018fb6.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{cases}
y_1 = d_1 + d_2 \\
y_2 = d_1 + 2d_2
\end{cases}"/>

<p>丢失1个数据块时只用 <code class="highlighter-rouge">y₁</code> 的方程就够了.
丢失2个数据块时才需要解二元一次方程组. 如果 <code class="highlighter-rouge">y₁</code> 或 <code class="highlighter-rouge">y₂</code> 丢失, 则通过重新取点的方式恢复.</p>

<blockquote>
  <p>我们可以在直线上取任意多个点, 但恢复时最多也只需要2个点就够了.</p>
</blockquote>

<h2 id="km的冗余的本质-高次曲线">k+m的冗余的本质: 高次曲线</h2>

<p>现在我们把它再推广到更一般的情况:
直线方程只有2个系数  <code class="highlighter-rouge">d₁, d₂</code> , 只能用于对2块数据做冗余,
如果要用描点方式来为更多的数据块生成冗余数据,
我们就需要有更多系数的方程, 也就是使用高次的曲线.</p>

<blockquote>
  <p>例如:
二次曲线抛物线 y = a x² + b x + c 需要3个系数来确定(可用来存储3块数据),
同时也需要知道抛物线上的3个点的坐标来找回这条抛物线.</p>
</blockquote>

<p>如果有k个数据块, 我们把k个数据作为系数, 来定义1条关于x的高次曲线,
再通过记录曲线上的点的坐标来实现冗余:</p>

<img src="/publish/wechat/storage/ec-1/images/y_=_d_1_d_2_x_d_3_x_2_d_k_x_k-1_-5471c2a2dae90c282fbadb0160c78e29.png" style="display: block; margin: 0 auto 1.3em auto" _alt="y = d_1 + d_2 x + d_3 x^2 + ... + d_k x^{k-1}"/>

<blockquote>
  <p>例如要存储4个数据<code class="highlighter-rouge">1, 2, 3, 4</code>, 则曲线方程是: <code class="highlighter-rouge">y = 1 + 2x + 3x² + 4x³</code>.
记录曲线上<code class="highlighter-rouge">x=1, 2, 3, 4</code> 时y的值, 如下图:</p>

  <p><img src="/post-res/ec-1/y-1-2x-3x2-4x3-pad.png" alt="y-1-2x-3x2-4x3" /></p>
</blockquote>

<ul>
  <li>
    <p>存储过程:</p>

    <p>取m个不同的x的值(1, 2, 3…m), 记录这条曲线上m个不同点的坐标:</p>

    <img src="/publish/wechat/storage/ec-1/images/1_y_2_y_m_y_m_-192711a4346a3eb62ca607345ba5952d.png" style="display: block; margin: 0 auto 1.3em auto" _alt="(1, y₁), (2, y₂) ... (m, y_m)"/>

    <p>存储所有k个数据块 <code class="highlighter-rouge">d₁, d₂ ...</code>.
和所有m个校验块 <code class="highlighter-rouge">y₁, y₂ ...</code>.</p>
  </li>
  <li>
    <p>恢复过程:</p>

    <p>平面上m个点可以唯一确定1条 m-1
次幂的曲线(或通过m个点跟k-m个已知系数确定一条k-1次幂的曲线).
确定了这条关于x的曲线,就找回了它的系数,也就是数据块</p>

    <img src="/publish/wechat/storage/ec-1/images/d_1_d_2_d_k-2239564f0d87e4198b1daeee07c34a0b.png" style="display: block; margin: 0 auto 1.3em auto" _alt="d_1, d_2 ... d_k"/>
  </li>
</ul>

<p>以上就是 EC存储跟恢复的几何本质:
<strong>一条k-1次曲线可以通过k个系数或曲线上的点来确定</strong>.</p>

<h2 id="从曲线方程到生成矩阵">从曲线方程到生成矩阵</h2>

<p>从EC的几何本质出发, 我们再系统的描述下生成校验块的过程:
为x取自然数的值(1,2,3…)来计算 y 的值:</p>

<img src="/publish/wechat/storage/ec-1/images/begin_aligned_y_1_=_d_1_1_d_2_1_2_d_3_dots_1_k-1_d_k_y_2_=_d_1_-8122cb31101942c27bf14ccaf40bd68f.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{aligned}
y_1 = d_1 + 1 d_2  + 1^2 d_3  + \dots  1^{k-1} d_k \\
y_2 = d_1 + 2 d_2  + 2^2 d_3  + \dots  2^{k-1} d_k \\
y_3 = d_1 + 3 d_2  + 3^2 d_3  + \dots  3^{k-1} d_k \\
...
\end{aligned}"/>

<p>把上面等式写成矩阵的形式, 就得到了EC校验块的 <strong>生成矩阵</strong> [Generator-Matrix]:</p>

<img src="/publish/wechat/storage/ec-1/images/CDATA_begin_bmatrix_y_1_y_2_y_3_y_m_end_bmatrix_=_begin_bmatrix-956c5dafca84853793e1ff7211b8fd0e.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{bmatrix}
y_1 \\
y_2 \\
y_3 \\
... \\
y_m
\end{bmatrix} =
\begin{bmatrix}
1   & 1   & 1^2 & ... & 1^{k-1} \\
1   & 2   & 2^2 & ... & 2^{k-1} \\
1   & 3   & 3^2 & ... & 3^{k-1} \\
... & ... & ... & ... & ...     \\
1   & m   & m^2 & ... & m^{k-1}
\end{bmatrix}
\times
\begin{bmatrix}
d_1 \\
d_2 \\
d_3 \\
... \\
d_k
\end{bmatrix} %]]>"/>

<p>这里 <code class="highlighter-rouge">y₁, y₂ ...</code> 就是校验块的数据,
因此, 上面[栗子3]中选择的系数, 就是从这里来的.</p>

<p><strong>而这个矩阵, 就是著名的 [Vandermonde] 矩阵</strong>.</p>

<blockquote>
  <p>[Vandermonde] 矩阵只是 EC 其中1种系数的选择方式.
其他常用的系数矩阵还有 [Cauchy] 矩阵等.</p>
</blockquote>

<h1 id="ec的解码-求解n元一次方程组">EC的解码: 求解n元一次方程组</h1>

<p>EC生成校验块的过程称之为EC的<strong>编码</strong>,
也就是用[Vandermonde]矩阵去乘所有的数据块.</p>

<p>而当数据丢失需要找回的时候,
使用的是EC的<strong>解码</strong>过程.</p>

<p>既然EC的编码过程是<strong>编码矩阵</strong>([Vandermonde])和数据块列相乘:</p>

<img src="/publish/wechat/storage/ec-1/images/CDATA_begin_bmatrix_1_1_1_1_1_2_4_2_k-1_1_3_9_3_k-1_1_m_m_1_m_k-1aaf5603dbcf4cc4bfcc723687693749.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{bmatrix}
1 & 1 & 1 & ... & 1 \\
1 & 2 & 4 & ... & 2^{k-1} \\
1 & 3 & 9 & ... & 3^{k-1} \\
... \\
1 & m & m^1 & ... & m^{k-1}
\end{bmatrix}
\times
\begin{bmatrix}
d_1 \\
d_2 \\
d_3 \\
... \\
d_k
\end{bmatrix} =
\begin{bmatrix}
y_1 \\
y_2 \\
y_3 \\
... \\
y_m
\end{bmatrix} %]]>"/>

<p>那么解码的过程就可以描述如下:</p>

<p>假设有q个数字丢失了, <code class="highlighter-rouge">q &lt;= m</code>.
从上面的<strong>编码矩阵</strong>中选择q行,
组成的一次方程组, 求解方程组算出丢失的数据.</p>

<p>例如 <code class="highlighter-rouge">d₂, d₃</code> 丢失了, 下面用 <code class="highlighter-rouge">u₂, u₃</code> 表示
(只丢失了2块数据, 不需要所有的m个校验块参与, 只需要2个校验块来恢复数据)</p>

<img src="/publish/wechat/storage/ec-1/images/CDATA_begin_bmatrix_1_1_1_1_1_2_4_2_k-1_end_bmatrix_times_begin-fabdb565866ab3ee59a48415c12dbe72.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{bmatrix}
1 & 1 & 1 & ... & 1 \\
1 & 2 & 4 & ... & 2^{k-1} \\
\end{bmatrix}

\times

\begin{bmatrix}
d_1 \\
u_2 \\
u_3 \\
... \\
d_k
\end{bmatrix} =

\begin{bmatrix}
y_1 \\
y_2 \\
\end{bmatrix} %]]>"/>

<p>这个矩阵表示的方程组里有2个未知数 <code class="highlighter-rouge">u₂, u₃</code> ,
解方程即可得到 <code class="highlighter-rouge">u₂, u₃</code> 这2块丢失的数据.</p>

<h2 id="vandermonde-矩阵保证方程组有解">[Vandermonde] 矩阵保证方程组有解</h2>

<p>对于k+m的EC来说, 任意丢失m个数据块都可以将其找回.
因为我们选择的[Vandermonde] 矩阵保证了任意<code class="highlighter-rouge">m</code>行<code class="highlighter-rouge">m</code>列组成的子矩阵都是线性无关的,
构成的方程肯定有确定解. 例如:</p>

<img src="/publish/wechat/storage/ec-1/images/CDATA_V=_begin_bmatrix_1_x_1_x_1_2_dots_x_1_n-1_1_x_2_x_2_2_dot-b9e3fa2d696f43be3809299922cab97d.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
V=\begin{bmatrix}
1      & x_1    & x_1^2  & \dots  & x_1^{n-1} \\
1      & x_2    & x_2^2  & \dots  & x_2^{n-1} \\
1      & x_3    & x_3^2  & \dots  & x_3^{n-1} \\
\vdots & \vdots & \vdots & \ddots & \vdots    \\
1      & x_m    & x_m^2  & \dots  & x_m^{n-1}
\end{bmatrix} %]]>"/>

<ul>
  <li>
    <p>[Vandermonde] 的 行列式的值为:</p>

    <img src="/publish/wechat/storage/ec-1/images/det_V_=_prod__1_leq_i_lt_j_leq_n_x_j_-_x_i_-7e308172ffdbff8b5536508bb0700c80.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\det(V)=\prod_{1 \leq i \lt j \leq n}(x_j - x_i)"/>

    <p>只要 xᵢ 都不同, 则 [Vandermonde] 矩阵的行列式就不为0, 矩阵可逆, 表示方程有唯一解.</p>
  </li>
  <li>
    <p>[Vandermonde] 矩阵的任意 <code class="highlighter-rouge">m x m</code> 的子矩阵, 是一个Generalized Vandermonde Matrix,
它在 xᵢ 都为正数时可以保证永远有唯一解.</p>

    <p>因此在<strong>实数</strong>领域, 我们总能保证上面这个冗余策略很好的工作.</p>
  </li>
</ul>

<p>好了, 到此为止我们讨论了EC在实数范围内的全部内容.
相信大家根据以上原理很容易写出一个简单但可靠的EC的实现.</p>

<p>但这套理论还不能直接应用到线上产品中.
因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,
通过[Vandermonde]矩阵生成校验块, 那校验块的数值几乎确定会溢出.</p>

<p>下一篇 Erasure-Code-擦除码-2-实现篇 中,
我们会展示出算数和计算机算法之间的差异,
以及我们将通过什么样的手段来解决这些问题, 将EC真正应用到生产环境中.</p>

<blockquote>
  <p>敬请关注:</p>
  <ul>
    <li>[第二篇:实现]</li>
    <li>第三篇:极限(疯狂编辑中)</li>
  </ul>
</blockquote>


        <p style="font-size: 0.7rem; font-weight: bolder;">
本文链接: [https://blog.openacid.com/storage/ec-1/]


<br/>
下载pdf: [Erasure-Code-擦除码-1-原理篇.pdf]

</p>
<ul class="page-links" style="display:block;">


<li style="font-size:0.7em">
[下载Erasure-Code-擦除码-1-原理篇.pdf]: https://blog.openacid.com/publish/pdf/storage/ec-1.pdf
</li>



    
        <li style="font-size:0.7em">
        [Vandermonde]: https://en.wikipedia.org/wiki/Vandermonde_matrix
        </li>
    

    
        <li style="font-size:0.7em">
        [Cauchy]: https://en.wikipedia.org/wiki/Cauchy_matrix
        </li>
    

    
        <li style="font-size:0.7em">
        [failure-rate]: https://www.backblaze.com/blog/hard-drive-reliability-stats-q1-2016/
        </li>
    

    
        <li style="font-size:0.7em">
        [RAID]: https://zh.wikipedia.org/wiki/RAID
        </li>
    

    
        <li style="font-size:0.7em">
        [RAID-5]: https://zh.wikipedia.org/wiki/RAID#RAID_5
        </li>
    

    
        <li style="font-size:0.7em">
        [RAID-6]: https://zh.wikipedia.org/wiki/RAID#RAID_6
        </li>
    

    
        <li style="font-size:0.7em">
        [Finite-Field]: https://en.wikipedia.org/wiki/Finite_field
        </li>
    

    
        <li style="font-size:0.7em">
        [Galois-Field]: https://en.wikipedia.org/wiki/Finite_field
        </li>
    

    
        <li style="font-size:0.7em">
        [Reed-Solomon]: https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction
        </li>
    

    
        <li style="font-size:0.7em">
        [Erasure-Code]: https://en.wikipedia.org/wiki/Erasure_code
        </li>
    

    
        <li style="font-size:0.7em">
        [Prime-Polynomial]: https://en.wikipedia.org/wiki/Irreducible_polynomial
        </li>
    

    
        <li style="font-size:0.7em">
        [Field-Extension]: https://en.wikipedia.org/wiki/Field_extension
        </li>
    

    
        <li style="font-size:0.7em">
        [Complex-Number]: https://en.wikipedia.org/wiki/Irreducible_polynomial#Field_extension
        </li>
    

    
        <li style="font-size:0.7em">
        [Hamming-7-4]: https://en.wikipedia.org/wiki/Hamming(7,4)
        </li>
    

    
        <li style="font-size:0.7em">
        [Generator-Matrix]: https://en.wikipedia.org/wiki/Generator_matrix
        </li>
    

    
        <li style="font-size:0.7em">
        [第一篇:原理]: https://blog.openacid.com/storage/ec-1
        </li>
    

    
        <li style="font-size:0.7em">
        [第二篇:实现]: https://blog.openacid.com/storage/ec-2
        </li>
    

    
        <li style="font-size:0.7em">
        [第三篇:极限]: https://blog.openacid.com/storage/ec-3
        </li>
    

</ul>
<p>
<img src="/assets/images/qrcode-text.png" alt="openacid">
</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
      
      
      [distributed]<span class="sep">, </span>
    
      
      
      [ec]<span class="sep">, </span>
    
      
      
      [erasure-code]<span class="sep">, </span>
    
      
      
      [GF256]<span class="sep">, </span>
    
      
      
      [replication]<span class="sep">, </span>
    
      
      
      [storage]<span class="sep">, </span>
    
      
      
      [伽罗瓦]<span class="sep">, </span>
    
      
      
      [伽罗瓦域]<span class="sep">, </span>
    
      
      
      [域]<span class="sep">, </span>
    
      
      
      [擦除码]<span class="sep">, </span>
    
      
      
      [纠删码]
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
    <span itemprop="keywords">
    
      
      
      [storage]
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2020-01-28T00:00:00+08:00">January 28, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  [<i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span>]

  [<i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span>]

  [<i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span>]
</section>


      
  <nav class="pagination">
    
      [向前]
    
    
      [向后]
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">留下评论</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        [Erasure-Code-擦除码-2-实现篇
]
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  60 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">书接上回

上一篇 第一篇:原理 中, 我们介绍了EC的基本原理,
实际上EC的存储跟恢复过程可以理解为:
一条k-1次曲线可以通过k个系数或曲线上的点来确定.

我们也提到:


  但这套理论还不能直接应用到线上产品中.
因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,
通过Vandermon...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        [Art of Pull Requests(翻译)
]
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  1 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">原文: Art of Pull Requests



正如我之前写的，
我们是一个远程团队，团队成员遍布世界各地。
这意味着code reviews 和 pull requests必须远程完成。

最近，我们团队的一位成员提出了这样的宣言:


  作为 PR writer 我会:

  
    保持PR够小...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        [掐指算算: 你的CDN多花了几百万?
]
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  5 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">在上篇
互联网中对象访问频率的91分布
我们通过
90%的流量由10%的内容产生
这句经验描述，
得出了访问频率的zipf模型:



CDN (Content delivery network)
就是一个典型的符合zipf分布的缓存系统:
将缓存服务部署在距离用户最近的上百个地区（CDN边缘机房），
当用户需要...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        [互联网中对象访问频率的91分布
]
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">在互联网领域, 流行着这么一句话:


  90%的流量由10%的内容产生.


缓存也由此产生: 只为最频繁访问的10%的内容提供更快的存储,
就可以以很低的成本提供尽可能好的服务质量.

一般符合这种互联网访问模型的曲线是下图这样的.
对每个访问的url做独立计数, 并按照从访问最多到最低排序:



这句是...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="输入您要搜索的关键词..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->



<script language="javascript" type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/SVG"],
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
        }
    });
</script>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG"> </script>




<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li>[<i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed]</li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 OpenACID-分布式研究小院. 技术来自于 [Jekyll] &amp; [Minimal Mistakes].</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-69976993-2']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>






    
  <script>
    var disqus_config = function () {
      this.page.url = "https://blog.openacid.com/storage/ec-1/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/storage/ec-1"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://openacid.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the [comments powered by Disqus.]</noscript>


  





  </body>
</html>
