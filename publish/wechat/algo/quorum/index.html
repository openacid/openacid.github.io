<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.20.2 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>后分布式时代: 多数派读写的’少数派’实现 - OpenACID Blog</title>
<meta name="description" content="通过减少多数派读写中参与者的数量, 可以实现分布式系统某些特定场景的优化, 以及介绍这些优化对系统可用性产生的影响, 根据什么标准来选择和调整这些参数.">


  <meta name="author" content="张炎泼(xp)">
  
  <meta property="article:author" content="张炎泼(xp)">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="OpenACID Blog">
<meta property="og:title" content="后分布式时代: 多数派读写的’少数派’实现">
<meta property="og:url" content="https://blog.openacid.com/algo/quorum/">


  <meta property="og:description" content="通过减少多数派读写中参与者的数量, 可以实现分布式系统某些特定场景的优化, 以及介绍这些优化对系统可用性产生的影响, 根据什么标准来选择和调整这些参数.">







  <meta property="article:published_time" content="2020-10-18T00:00:00+08:00">





  

  


<link rel="canonical" href="https://blog.openacid.com/algo/quorum/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "OpenACID-分布式研究小院",
      "url": "https://blog.openacid.com/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="OpenACID Blog Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="apple-touch-icon" sizes="180x180"    href="/assets/images/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
<link rel="manifest"                            href="/assets/images/favicon/site.webmanifest">

<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">跳转链接</h2>
  <ul>
    <li>[转到主导航栏]</li>
    <li>[转到内容]</li>
    <li>[转到底部]</li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please [upgrade your browser] to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo/icon-lemon-margin.png" alt=""></a>
        
        <a class="site-title" href="/">
          OpenACID Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              [About Us]
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">切换搜索</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">
  
  
  <p>

  
    <div class="author__avatar">
      
        <img src="/assets/images/author/xp.jpg" alt="张炎泼(xp)" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">张炎泼(xp)</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>正在学画画, 主业是码农</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <li>[<i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">个人博客</span>]</li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      
        <li>
          [
            <i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span>
          ]
        </li>
      

      

      

      

      

      

      

      

      

      

      
        <li>
          [
            <i class="fab fa-fw fa-weibo" aria-hidden="true"></i><span class="label">Weibo</span>
          ]
        </li>
      

      

      

      

      <!--
  <li>
    [
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    ]
  </li>
-->
    </ul>
  </div>

  </p>
  
</div>

  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="后分布式时代: 多数派读写的’少数派’实现">
    <meta itemprop="description" content="通过减少多数派读写中参与者的数量, 可以实现分布式系统某些特定场景的优化, 以及介绍这些优化对系统可用性产生的影响, 根据什么标准来选择和调整这些参数.">
    <meta itemprop="datePublished" content="2020-10-18T00:00:00+08:00">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">后分布式时代: 多数派读写的’少数派’实现
</h1>
          

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          17 分钟阅读
        
      </span>
    
  </p>


        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> 本文目录</h4></header>
              <ul class="toc__menu">
  <li>[前言]</li>
  <li>[多数派读写:分布式系统的基础]
    <ul>
      <li>[Quorum vs Majority]</li>
    </ul>
  </li>
  <li>[不是majority的quorum们]
    <ul>
      <li>[带权重的quorum]</li>
      <li>[包含特定元素的quorum]</li>
      <li>[4/5 加 2/5的quorum]</li>
      <li>[Hierarchical quorum 3x3]</li>
      <li>[Hierarchical quorum 2xn]</li>
    </ul>
  </li>
  <li>[通过设计 quorum 降低延迟]</li>
  <li>[quorum 决定了系统的可用性]
    <ul>
      <li>[系统可用性的 quorum 定义]</li>
      <li>[quorum 的可用性分析]</li>
    </ul>
  </li>
  <li>[应用场景]
    <ul>
      <li>[zookeeper 使用 hierarchical quorum 的例子]</li>
      <li>[用 quorum 来优化链路选择: 边缘存储场景]</li>
    </ul>
  </li>
  <li>[总结: quorum 在分布式系统中的意义]</li>
</ul>

            </nav>
          </aside>
        
        <p style="font-size: 0.7rem; font-weight: bolder;">
本文链接: [https://blog.openacid.com/algo/quorum/]


</p>


        
          



<img src="/post-res/quorum/quorum-banner-small.jpg" alt="后分布式时代: 多数派读写的'少数派'实现" class="page__hero-image">

        

        <h1 id="前言">前言</h1>

<p>paxos可以看做是2次 [多数派读写] 完成一次强一致读写.  多数派要求半数以上的参与者(paxos中的Acceptor)接受某笔操作.  但 [多数派读写] 并不一定需要多于半数的参与者, 分布式系统中某些场合的优化, 可以通过减少参与者数量来完成的.</p>

<h1 id="多数派读写分布式系统的基础">多数派读写:分布式系统的基础</h1>

<p>分布式系统中, 其中一个基础的问题是如何在不可靠硬件(低可用性)基础上构建可靠(高可用性)的服务,
要达成这个目标, 核心的手段就是复制(例如一份数据存3个副本).
而复制过程中的一致性问题, 最后都归结为paxos的解决方案. 这些我们在 [paxos的直观解释] 中做了详细的介绍.</p>

<p>在 [paxos的直观解释] 的 [slide-20] 中, 我们了解到, paxos是通过2次 [多数派读写] 来完成强一致的读写:</p>

<blockquote>
  <p>这个方法之所以能工作也是因为多数派写中, 一个系统最多只能允许一个多数派写成功.
paxos也是通过2次多数派读写来实现的强一致.</p>
</blockquote>

<p>也就是说, [多数派读写] 在分布式领域是一个更基础的问题.
在 [paxos的直观解释] 中也简单介绍了一下 [多数派读写]:</p>

<blockquote>
  <p><strong>[slide-10]</strong>
为了解决半同步复制中数据不一致的问题, 可以将这个复制策略再做一改进: <strong>多数派读写</strong>: 每条数据必须写入到<strong>半数以上</strong>的机器上. 每次读取数据都必须检查<strong>半数以上</strong>的机器上是否有这条数据.</p>

  <p>在这种策略下, 数据可靠性足够, 宕机容忍足够, 任一机器故障也能读到全部数据.</p>
</blockquote>

<p><img src="/post-res/quorum/nwr.jpg" alt="img" /></p>

<p>[多数派读写], 也可称作 quorum-rw, wikipedia上的描述如下:</p>

<blockquote>
  <p>在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。</p>

  <p>算法来源于Gifford, 1979。 分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（Vr），每个写操作获得的票数必须大于最小写票数（write quorum）(Vw）才能读或者写。如果系统有V票（意味着一个数据对象有V份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：</p>

  <ol>
    <li>Vr + Vw &gt; V</li>
    <li>Vw &gt; V/2</li>
  </ol>
</blockquote>

<p>🌰 举个例子, 如果有5个存储节点<code class="highlighter-rouge">{a, b, c, d, e}</code>,
一笔操作给x赋值为3(x=3) 成功写入了abc 3个节点, 那么另外一个读, 只要联系到任意3个节点,
就一定能读到x=3
这就是安全的.</p>

<p>要联系到至少3个节点, 在某些场景下仍然是昂贵的, 例如一个全球分布的DB,
2个机房之间延迟可能达到上百毫秒.
我们有时希望通过减少必须参与的节点数量, 从而提升系统的性能.
于是我们先从概念开始, 看看quorum-rw中的quorum是什么:</p>

<h2 id="quorum-vs-majority">Quorum vs Majority</h2>

<p>在很多paper中, 是不区分quorum和majority的差别的:</p>

<ul>
  <li>
    <p>majority就是”多数派”的意思(也就是<strong>多于半数</strong>, <code class="highlighter-rouge">≥⌊n/2⌋+1</code>), 例如5节点中选3个;</p>
  </li>
  <li>
    <p>quorum, 翻译为”法定人数”( 🤔 WT…?  ), 它不一定是多数, 但需要满足一个条件,
就是任意2个quorum必须有交集(majority已经满足了这个要求).
所以在本文中, <strong>我们将quorum看做majority概念的一个推广; majority是quorum的一个特例</strong>.</p>
  </li>
</ul>

<p>一般我们提到quorum(或majority)时, 都是指一个节点集合Q, 本文中我们把一个系统中所有quorum的集合记为:
<img src="/publish/wechat/algo/quorum/images/mathbb_Q_=_Q_1_Q_2_-e00a2260c10c79813dd9a3e9622c0497.png" style="height: 0.8em" _alt="\mathbb{Q} = \{ Q_1, Q_2... \}"/>,
其中
<img src="/publish/wechat/algo/quorum/images/Q_k_=_a_i_a_j_-79869aee4578404dec9182641864e9e9.png" style="height: 0.8em" _alt="Q_k = \{a_i, a_j...\}"/>
是一个节点(paxos中的Acceptor)的集合, 例如一个三节点系统<code class="highlighter-rouge">{a, b, c}</code>, 它的majority的quorum集合:</p>

<img src="/publish/wechat/algo/quorum/images/begin_bmatrix_mathbb_Q_=_a_b_b_c_c_a_a_b_c_end_bmatrix_-dd2931895a0eaf9332057cfc1cce523d.png" style="zoom: 60%; display: block; margin: 0 auto 1.3em auto" _alt="
\begin{bmatrix}
\mathbb{Q} = \{
& \{a, b\}, \\
& \{b, c\}, \\
& \{c, a\}, \\
& \{a, b, c\} \\
\} \\
\end{bmatrix} "/>

<p>现在再回到问题, 要保证quorum-rw的正确性, 就要求一次成功的写入, 必须能成功读取,
从这点看, 过半数这个要求是可以放宽的:</p>

<p>只需要quorum保证<strong>任意2个quorum有交集</strong>就可以.</p>

<blockquote>
  <p>在[paxos made simple]中, 也就是classic paxos的paper中, [Leslie Lamport] 还在使用majority这个名称来表示多数派, 在后面的paper, fast-paxos, generalized paxos中,都换成了quorum这个名词.</p>

  <p>虽然在paper中都是”majority”的意思, 但quorum的适用范围更广.</p>
</blockquote>

<p>我们看几个非majority的quorum的例子, 这些quorum都不是传统意义上的majority,
但都可以实现majority同样的功能, 为quorum-rw或paxos提供正确性保证:</p>

<h1 id="不是majority的quorum们">不是majority的quorum们</h1>

<h2 id="带权重的quorum">带权重的quorum</h2>

<p><code class="highlighter-rouge">{a, b, c, d, e}</code> 5个节点中, 把a, b, c三个节点部署到一起: <code class="highlighter-rouge">{ abc, d, e}</code>(abc必须同时选).
如果选abc, 就记3票, d, e只记一票.</p>

<p>3个成员一共5票, 所有票数过半的集合都是quorum: <code class="highlighter-rouge">{abc}</code>, <code class="highlighter-rouge">{abc, d}</code>, <code class="highlighter-rouge">{abc, e}</code>, <code class="highlighter-rouge">{abc, d, e}</code>.
但<code class="highlighter-rouge">{d, e}</code> 不是一个quorum, 因为根据我们的定义, 只有2票没有过半.</p>

<p>这样, 任意2个quorum都有交集<code class="highlighter-rouge">{abc}</code>.
那么quorum-rw算法, 如果选择任意一个quorum写, 另一个进程选择任意一个quorum读,
都可以实现安全的读写.</p>

<h2 id="包含特定元素的quorum">包含特定元素的quorum</h2>

<p>从上面的例子, 可以直接去掉majority的概念, 就是一类特殊的quorum集合:
<strong><img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 中每个quorum都必须包含某个特定元素</strong>:</p>

<p>如果集群是3个节点<code class="highlighter-rouge">{a,b,c}</code>, 定义每个quorum都必须包含a, 那么:
<img src="/publish/wechat/algo/quorum/images/mathbb_Q_=_a_a_b_a_c_a_b_c_-0841771fa0d628b20965c30fcf07f64e.png" style="height: 0.8em" _alt="\mathbb{Q} = \{ \{a\}, \{a,b\}, \{a,c\}, \{a,b,c\} \}"/>.</p>

<p>任意2个quorum都有交集<code class="highlighter-rouge">{a}</code>, 用这个quorum定义来运行paxos, 仍然是正确的. (可以试试跑一个之前
[paxos的直观解释] 中的例子里的paxos)</p>

<h2 id="45-加-25的quorum">4/5 加 2/5的quorum</h2>

<p>在一个5节点集群<code class="highlighter-rouge">{a,b,c,d,e}</code> 中, quorum定义为:至少包含4个元素, 或是<code class="highlighter-rouge">{a,b}</code>
那么<img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 就是:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{a, b, c, d}
{a, b, c, e}
{a, b, d, e}
{a, c, d, e}
{b, c, d, e}
{a, b}
</code></pre></div></div>

<p>任一4个元素的quorum都有交集, 任一4元素的quorum也和<code class="highlighter-rouge">{a,b}</code>有交集.
能用来跑paxos.</p>

<h2 id="hierarchical-quorum-3x3">Hierarchical quorum 3x3</h2>

<p>[hierarchical quorum] 是一个分层的quorum定义,
假设集群有9个节点, 排列成3x3的矩阵, 这里quorum的定义为: <strong>至少包括2行, 每行中至少包含2个节点</strong>.</p>

<p>容易看出任意2个quorum必有交集, 例如 <code class="highlighter-rouge">{a1, a2, b1, b2}</code> 和 <code class="highlighter-rouge">{b2, b3, c2, c3}</code> 有一个交集<code class="highlighter-rouge">{b2}</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.------.
|a1  a2| a3
|   .--|---.
|b1 |b2| b3|
'------'   |
c1  |c2  c3|
    '------'
</code></pre></div></div>

<p>以此quorum定义替代majority, 运行多数派读写或paxos一样是正确的.</p>

<h2 id="hierarchical-quorum-2xn">Hierarchical quorum 2xn</h2>

<p>继续沿用hierarchical quorum 的定义, 但只选2行.
因为一个2节点的系统<code class="highlighter-rouge">{x, y}</code>, quorum集合可以是
<img src="/publish/wechat/algo/quorum/images/mathbb_Q_=_x_x_y_-421e1d785a7058c72944e943dab77295.png" style="height: 0.8em" _alt="\mathbb{Q} = \{ \{x\}, \{x, y\} \}"/>
(或
<img src="/publish/wechat/algo/quorum/images/mathbb_Q_=_x_y_y_-492372d566ecbf8d465917cd2f333d38.png" style="height: 0.8em" _alt="\mathbb{Q} = \{ \{x, y\}, \{y\} \}"/>
),
(这里x, y代表一行).</p>

<p>于是这个场景中的quorum 可以描述为:
<strong>包含第一行的majority, 或在每一行都包含一个majority</strong>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a1 a2 a3
b1 b2 b3 b4 b5
</code></pre></div></div>

<p>容易看出按照这个规则选出的quorum, 任意2个都有交集.
例如:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{a1, a3}
{
  a1, a2,
  b1, b2, b3,
}
</code></pre></div></div>
<p>有交集<code class="highlighter-rouge">{a1}</code>.</p>

<p>[raft] 使用了这种quorum定义来完成集群变更, 基于hierarchical
quorum的选主在raft中叫做[joint consensus].</p>

<h1 id="通过设计-quorum-降低延迟">通过设计 quorum 降低延迟</h1>

<p>任何一种quorum的定义, 都可以用来替代majority来实现quorum-rw, 或paxos, 并严格保证正确性.
但是, 选择一种quorum, 将直接影响系统的性能和可用性.</p>

<p>首先最直观的结论是, quorum定义中所需的节点个数越少,
完成一次quorum-rw或paxos的消息量就越少, 如果可以选择到更近的节点,
那么整个系统的延迟就有可能会降低.</p>

<h1 id="quorum-决定了系统的可用性">quorum 决定了系统的可用性</h1>

<p>另一方面, 不同的quorum的选择, 会直接影响系统的可用性:</p>

<p><strong>任何一种quorum的选择, 可用性都低于majority的quorum</strong>.</p>

<p>非majority的quorum,
允许更少的可用节点,
以3x3的hierarchical quorum存储为例,
一次写入如果选择了左上的4个节点, 就达到了quorum要求, 只需要不到半数的节点参与.
看似容忍了更多(5个)故障,
但它整体的可用性要低于majority的quorum.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.-----.
|a1 a2| a3
|b1 b2| b3
'-----'
c1  c2  c3
</code></pre></div></div>

<h2 id="系统可用性的-quorum-定义">系统可用性的 quorum 定义</h2>

<p>一个分布式系统的可用性, 可以从一下几方面去考虑, 假设:</p>
<ul>
  <li>集群中的节点随机停机;</li>
  <li>并假设一段时间内一个服务器停机时间比例p=0.01(差不多相当于一个服务器一年有3天左右的时间不在线);</li>
  <li>且停机事件彼此独立.</li>
</ul>

<p>某个时刻, <strong>如果在线的节点集合是一个quorum,
那系统就可用, 可以通过在线节点集合这个quorum完成多数派读写或paxos; 否则就是系统不可用</strong>.</p>

<blockquote>
  <p>🌰 例如 <code class="highlighter-rouge">{a, b, c}</code> 三个节点, 选择majority的quorum,</p>
  <ul>
    <li>a, b 在线, c停机时, <code class="highlighter-rouge">{a, b}</code> 是一个quorum 所以系统可以正常运行.</li>
    <li>如果a在线, b, c都停机, <code class="highlighter-rouge">{a}</code> 不是一个quorum, 所以系统这时就不可用了.</li>
  </ul>
</blockquote>

<p>因此整个系统的可用性可以定义为: <strong>每个quorum出现的概率之和: <img src="/publish/wechat/algo/quorum/images/P_mathbb_Q_=_P_Q_i_Q_i_mathbb_Q_-f0c95729bfae43418fdc035733a888e3.png" style="height: 0.8em" _alt="P( \mathbb{Q} ) = ΣP(Q_i), Q_i ∈ \mathbb{Q}"/>.
quorum出现的概率是: P(Qᵢ) = (1-p)ˣpⁿ⁻ˣ,
其中x是一个quorum包含的节点个数: x = |Qᵢ|</strong>.</p>

<blockquote>
  <p>🌰 对一个三节点的系统 <code class="highlighter-rouge">{a, b, c}</code>
majority 的quorum集合 <img src="/publish/wechat/algo/quorum/images/mathbb_M_=_a_b_b_c_c_a_a_b_c_-23cfdbb609c8da2d930c756147033ec6.png" style="height: 0.8em" _alt="\mathbb{M} = \{ \{a, b\}, \{b, c\}, \{c, a\}, \{a, b, c\} \}"/>,
那么3个节点可能出现的所有状态, 以及对应的整个系统是否可用如就如下展示:</p>
  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0)  {}        (1-p)⁰p³    // unavailable
1)  {a}       (1-p)¹p²    // unavailable
2)  {b}       (1-p)¹p²    // unavailable
3)  {c}       (1-p)¹p²    // unavailable
4)  {a, b}    (1-p)²p¹    // available
5)  {b, c}    (1-p)²p¹    // available
6)  {c, a}    (1-p)²p¹    // available
7)  {a, b, c} (1-p)³p⁰    // available
</code></pre></div>  </div>

  <p>如果选择majority的quorum来构建系统,
那系统可用的概率是后4行状态概率相加:
C(3, 2)(1-p)²p¹ + C(3, 3)(1-p)³p⁰ ~= 1-4p² ~= 0.9996, 大约3个9</p>

  <p>如果选择另一种quorum, 例如去掉<code class="highlighter-rouge">{a, b}</code>, 加入<code class="highlighter-rouge">{c}</code>, 那这时可用性是第3, 5, 6, 7行相加:
(1-p)¹p² + 2 (1-p)²p¹ + (1-p)³p⁰ = 1-p, 大约2个9,
此时系统中每个quorum都包含c, c在线或停机直接决定了系统的可用性, 所以系统可用性也就是直接等于了c节点的可用性.</p>
</blockquote>

<h2 id="quorum-的可用性分析">quorum 的可用性分析</h2>

<p>然后我们来看看为什么非majority的quorum 会降低系统的可用性:</p>

<ul>
  <li>假设majority quorum的集合为 <img src="/publish/wechat/algo/quorum/images/mathbb_M_-a5df6eb8e14d1fd23a6946096d0e8ad4.png" style="height: 0.8em" _alt="\mathbb{M}"/>, 也就是所有大小过半的节点集合;</li>
  <li>对某一个quorum集合<img src="/publish/wechat/algo/quorum/images/mathbb_Q_=_Q_1_Q_2_-0300b7ecf345bff450cb0e64c41512ee.png" style="height: 0.8em" _alt="\mathbb{Q} = \{Q_1, Q_2...\}"/>,
其中 <img src="/publish/wechat/algo/quorum/images/Q_k_=_a_i_a_j_-79869aee4578404dec9182641864e9e9.png" style="height: 0.8em" _alt="Q_k = \{a_i, a_j...\}"/> 是一个节点集合,
Qₓ满足对quorum的定义: 任意2个Qᵢ, Qⱼ交集都不为空: <img src="/publish/wechat/algo/quorum/images/Q_i_Q_j_emptyset-eb293bdee267b02346229797a482b428.png" style="height: 0.8em" _alt="Q_i ∩ Q_j ≠ \emptyset"/>;</li>
  <li>单机停机几率 p = 0.01;</li>
</ul>

<p>我们可以对<img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 做一个变换 <img src="/publish/wechat/algo/quorum/images/f_mathbb_Q_-c0360728970cb8a651d2b8213eb7e794.png" style="height: 0.8em" _alt="f(\mathbb{Q})"/>:</p>

<p>从 <img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 中选择最小的一个Qᵢ: Qᵢ满足<code class="highlighter-rouge">∀Qⱼ: |Qᵢ| ≤ |Qⱼ|</code> (如果有多个最小的, 选任意一个), 从<img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 中去掉Qᵢ, 再把Qᵢ的补集加入:</p>

<img src="/publish/wechat/algo/quorum/images/mathbb_Q_=_mathbb_Q_backslash_Q_i_overline_Q_i_-6bedd36c358f20421ac0da8f18960890.png" style="zoom: 60%; display: block; margin: 0 auto 1.3em auto" _alt="\mathbb{Q}' = {\mathbb{Q}} \backslash \{ Q_i\} ∪ \{\overline{Q_i}\}"/>

<blockquote>
  <p><strong><img src="/publish/wechat/algo/quorum/images/mathbb_Q_-143566156ff233bc361dca7746848c36.png" style="height: 0.8em" _alt="\mathbb{Q}'"/>也还是一个合法quorum集合</strong>:
因为对任意一个Qⱼ, 如果<img src="/publish/wechat/algo/quorum/images/Q_j_Q_i_-09252ae53dad9594116d5743bd86d558.png" style="height: 0.8em" _alt="|Q_j| ≥ |Q_i|"/>  且 <img src="/publish/wechat/algo/quorum/images/Q_j_Q_i-f01f9ce8e1842fe5b3c6f355f7e417c0.png" style="height: 0.8em" _alt="Q_j ≠ Q_i"/>, 那么Qⱼ一定包含一个不在Qᵢ中的节点,
所以 <img src="/publish/wechat/algo/quorum/images/overline_Q_i_-dc953923411319e68f647380206b40ee.png" style="height: 0.8em" _alt="\overline{Q_i}"/> 和 <img src="/publish/wechat/algo/quorum/images/Q_j-beb195239568309b3e3a0ce19bb5b987.png" style="height: 0.8em" _alt="Q_j"/> 一定有交集.</p>
</blockquote>

<p>重复这个步骤直到 <img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 中所有quorum的大小都大于半数. 最后 <img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 就变成了一个<img src="/publish/wechat/algo/quorum/images/mathbb_M_-a5df6eb8e14d1fd23a6946096d0e8ad4.png" style="height: 0.8em" _alt="\mathbb{M}"/> 的子集:
<img src="/publish/wechat/algo/quorum/images/f_mathbb_Q_mathbb_M_-e94281416192cc68e816ac47569d1bab.png" style="height: 0.8em" _alt="f(\mathbb{Q}) ⊆ \mathbb{M}"/></p>

<p>这样, <strong>任何一个 <img src="/publish/wechat/algo/quorum/images/mathbb_Q_-5eac308e29708e918ed13a88a4249b74.png" style="height: 0.8em" _alt="\mathbb{Q}"/> 都可以跟 <img src="/publish/wechat/algo/quorum/images/mathbb_M_-a5df6eb8e14d1fd23a6946096d0e8ad4.png" style="height: 0.8em" _alt="\mathbb{M}"/> 的一个子集建立一个一一映射.
而 <img src="/publish/wechat/algo/quorum/images/mathbb_M_-a5df6eb8e14d1fd23a6946096d0e8ad4.png" style="height: 0.8em" _alt="\mathbb{M}"/> 的子集的可用性一定不大于 <img src="/publish/wechat/algo/quorum/images/mathbb_M_-a5df6eb8e14d1fd23a6946096d0e8ad4.png" style="height: 0.8em" _alt="\mathbb{M}"/> 的可用性</strong>:
<img src="/publish/wechat/algo/quorum/images/P_subset_mathbb_M_P_mathbb_M_-ef721cbecb39ae76f7c9908faa93262f.png" style="height: 0.8em" _alt="P(subset(\mathbb{M})) ≤ P(\mathbb{M})"/>.</p>

<p>而且, <strong>对一个不大于半数的Qᵢ(<code class="highlighter-rouge">x = |Qᵢ| ≤ ⌊n⌋/2</code>), 它的补集在随机停机过程中出现的几率更大</strong>:</p>

<img src="/publish/wechat/algo/quorum/images/1-p_xp_n-x_1-p_n-x_p_x_P_Q_i_P_overline_Q_i_P_mathbb_Q_P_f_Q_-017b7aa618c35a0595bfbcd1018dc5ff.png" style="zoom: 60%; display: block; margin: 0 auto 1.3em auto" _alt="(1-p)^xp^{n-x} ≤ (1-p)^{n-x}p^x ⇒ P(Q_i) ≤ P(\overline{Q_i})  ⇒ P(\mathbb{Q}) ≤ P(f(Q))"/>

<p>∴ <img src="/publish/wechat/algo/quorum/images/P_mathbb_Q_P_f_mathbb_Q_P_mathbb_M_-172504fa84b0e9403f6402c683085813.png" style="height: 0.8em" _alt="P(\mathbb{Q}) ≤ P(f(\mathbb{Q})) ≤ P(\mathbb{M})"/>, 即 majority 的 quorum 可靠性最高. 其他任何一种quorum的选择, 即使它允许更多的节点停机, 也只能提供较低的可用性.</p>

<blockquote>
  <p>🌰 例如我们算下, 3x3 的 hierarchical quoru m的可用性:</p>
  <ul>
    <li>majority 3 节点的停机概率是: <code class="highlighter-rouge">Pm3 = C(3, 2)(1-p)²p + C(3, 3)(1-p)³</code></li>
    <li>Pm3也就是每个机房的停机概率, 把每个机房看做一个大的节点, 因此3个机房组成的majority quorum的不在线几率是: <code class="highlighter-rouge">Ph9 = C(3, 2)(1-Pm3)²Pm3 + C(3, 3)(1-Pm3)³</code></li>
  </ul>

  <p>我们用 [hierarchical-quorum.py] 这个小程序计算如下:</p>

  <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>failure-rate:
  majority of 3 nodes:        2.98e-04
  majority of 7 nodes:        3.42e-07
  majority of 9 nodes:        1.22e-08
  hierarchical quorum of 3x3: 2.66e-07
</code></pre></div>  </div>

  <p>可以看到hierarchical 3x3 的可用性比majority 9节点的可用性要低1个9.
差不多相当于7节点的majority 可用性.</p>
</blockquote>

<h1 id="应用场景">应用场景</h1>

<h2 id="zookeeper-使用-hierarchical-quorum-的例子">zookeeper 使用 hierarchical quorum 的例子</h2>

<p>🌰 [zookeeper] 的配置允许分组的概念, 就是使用了这种quorum定义, 它允许多于半数(5个/9个)节点停机.
例如在我们之前实现的3机房部署中, 就使用了3个机房(DC),
每个机房3个zookeeper实例的配置:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            zookeeper
                |
    .-----------+----------.
   /            |           \
  DC-1         DC-2         DC-3
 / | \        / | \        / | \
a1 a2 a3     b1 b2 b3     c1 c2 c3
--------     --------     --------
   | `- 30ms -'    `- 30ms -' |
   `---------- 60ms ----------'
</code></pre></div></div>

<p>[hierarchical quorum] 的一个优势在于在系统可用的状态下,
<strong>只需要联系2个机房就可以完成一次读写</strong>.</p>

<p>我们假设一个接近现实场景:</p>
<ul>
  <li>DC-1 和 DC-2之间的延迟是30ms,</li>
  <li>DC-2 和 DC-3之间也是30ms,</li>
  <li>DC-1 和 DC-3之间比较远, 延迟是60ms,</li>
</ul>

<p>那么选择 hierarchical quorum 所产生的延迟就在一定概率上比majority
quorum的延迟低.</p>

<p>例如, 现在只观察DC-1的写入请求, 最优情况下它只需联系最近的机房(DC-2)来完成一次paxos.
如果宕机2个节点:</p>
<ul>
  <li>hierarchical quorum 需要联系DC-3的条件是: 这2个宕机节点都集中在DC-1或都集中在DC-2时;</li>
  <li>majority quorum     需要联系DC-3的条件是: 这2个宕机节点都不在DC-3时.</li>
</ul>

<p>在宕机2个节点时, hierarchical 只有 majority 40% 的几率延迟达到 60ms;
如果假设单个节点停机几率是p=0.01(1年有3, 4天不在线),
那么9节点宕机2个节点的几率大约是0.0033,
差不多在99分位上, 延迟可以从60ms降低到30ms.</p>

<h2 id="用-quorum-来优化链路选择-边缘存储场景">用 quorum 来优化链路选择: 边缘存储场景</h2>

<p>🌰 传统的存储+CDN架构是用户传输到中心, 之后在下载时, 再通过边缘机房访问,
边缘机房没有则回中心拉取.
且边缘机房之间没有架构级别的关联, 各自在设计上是独立的:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Center Storage + CDN:
            client
            |  ↑
            |  |
  edge DCs  |  e₁   e₂   e₃
            |    ↖  ↑  ↗
center DC   `-----→ c
</code></pre></div></div>

<p>假设我们现在有一个边缘存储的系统: 3个分布在各地的边缘机房eᵢ, 和一个中心机房c.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Edge Storage:
               client
               ↑
               ↓
  edge DCs     e₁ - e₂ - e₃   // weight = 1
                 \  |  /
center DC           c         // weight = 2
</code></pre></div></div>

<ul>
  <li>
    <p>边缘存储的特点是, 一个中心机房c, 一般包含全量数据, 做数据的集中处理, 归档等.
写入一般分散在各个边缘机房, 方便就近接入用户请求.
可以把边缘存储想象成支持本地就近上传的CDN.</p>
  </li>
  <li>
    <p>边缘跟中心的链路一般很好. 但也会有故障, 边缘跟边缘之间链路质量一般.
因此在处理用户写请求时, 尽可能让边缘机房eᵢ优先选择跟中心机房c同步, 当联系不到中心机房时, fallback到几个边缘机房之间达成一致完成一笔写入.</p>

    <p>边缘存储的架构相比传统存储+CDN的模式, 可以让写入直接落在边缘机房, 省去了一次不必要的带宽.</p>
  </li>
</ul>

<p>在这个例子中, 我们设置中心机房c权重为2; 3个边缘机房, 权重各为1,
quorum定义成带权重的quorum: 一个quorum所包含的节点权重之和至少为3.</p>

<p>假设有1笔写入出现在e₁, 如果它跟中心机房c可以直接通信,
那就通过quorum <code class="highlighter-rouge">{e₁, c}</code> 直接完成一次多数派写入.
或者当时跟中心连接抖动, 那么它也可以联系e₂, e₃, 通过quorum <code class="highlighter-rouge">{e₁, e₂, e₃}</code>完成一次多数派写入.</p>

<h1 id="总结-quorum-在分布式系统中的意义">总结: quorum 在分布式系统中的意义</h1>

<p>几年前在一个机房里用paxos协同起来的分布式系统, 可以看做是分布式的从0到1的一步, 解决了<strong>分布</strong>问题.</p>

<p>分布式系统近年的发展越来越倾向于异构, 非对等, 大规模的架构共存于一个系统内.
这就对一致性算法提出了新的要求, 现代分布式系统都在尝试解决从1到100的问题:
将可用的系统打造成适应各种复杂场景的可靠系统(而不是简单的单机房几个服务器的单一场景):
系统在节点延迟/故障率/性能等变得越来越复杂的情况下,
系统设计的重心从正确性转移到调优方面,
例如如何让读写倾向于集中在高性能或更稳定的节点上, 或者让读写的流量优先最近的.</p>

<p>通过选择合适的quorum, 我们可以在这些<strong>复杂一些</strong>的系统中, 允许业务在可用性, 延迟, 性能之间做一个权衡:</p>

<ul>
  <li>
    <p>减少消息数量/延迟, 例如像<strong>zookeeper</strong> hierarchical quorum中的异地多活的例子, 可用性从8个9降低到7个9(假设7个9够用了:D), 换来更稳定的写入延迟: P99 延迟可以从60ms降低到30ms.</p>
  </li>
  <li>
    <p>使用加权重的quorum, 来实现<strong>边缘存储</strong>这种非对等系统中的链路选择和fallback机制.</p>
  </li>
  <li>
    <p>或实现更灵活的配置变化, 例如[raft] 的成员变更算法.</p>
  </li>
</ul>


        <p style="font-size: 0.7rem; font-weight: bolder;">
本文链接: [https://blog.openacid.com/algo/quorum/]


</p>
<ul class="page-links" style="display:block;">




    
        <li style="font-size:0.7em">
        [raft]: https://raft.github.io/
        </li>
    

    
        <li style="font-size:0.7em">
        [joint consensus]: https://github.com/peterbourgon/raft/blob/master/JOINT-CONSENSUS.md
        </li>
    

    
        <li style="font-size:0.7em">
        [Classic Paxos]: http://lamport.azurewebsites.net/pubs/pubs.html#paxos-simple
        </li>
    

    
        <li style="font-size:0.7em">
        [Fast Paxos]: http://lamport.azurewebsites.net/pubs/pubs.html#fast-paxos
        </li>
    

    
        <li style="font-size:0.7em">
        [paxos的直观解释]: https://blog.openacid.com/algo/paxos
        </li>
    

    
        <li style="font-size:0.7em">
        [Leslie Lamport]: http://www.lamport.org/
        </li>
    

    
        <li style="font-size:0.7em">
        [多数派读写]: https://zh.wikipedia.org/wiki/Quorum_(分布式系统)
        </li>
    

    
        <li style="font-size:0.7em">
        [paxos made simple]: http://lamport.azurewebsites.net/pubs/pubs.html#paxos-simple
        </li>
    

    
        <li style="font-size:0.7em">
        [hierarchical quorum]: https://zookeeper.apache.org/doc/r3.3.2/zookeeperHierarchicalQuorums.html
        </li>
    

    
        <li style="font-size:0.7em">
        [hierarchical-quorum.py]: /post-res/quorum/hierarchical-quorum.py
        </li>
    

    
        <li style="font-size:0.7em">
        [zookeeper]: https://zookeeper.apache.org/
        </li>
    

    
        <li style="font-size:0.7em">
        [slide-10]: https://blog.openacid.com/algo/paxos/#slide-10
        </li>
    

    
        <li style="font-size:0.7em">
        [slide-20]: https://blog.openacid.com/algo/paxos/#slide-20
        </li>
    

</ul>
<p>
<img src="/assets/images/qrcode-hori.jpg" alt="openacid">
</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
      
      
      [distributed]<span class="sep">, </span>
    
      
      
      [majority]<span class="sep">, </span>
    
      
      
      [paxos]<span class="sep">, </span>
    
      
      
      [quorum]<span class="sep">, </span>
    
      
      
      [raft]<span class="sep">, </span>
    
      
      
      [replication]<span class="sep">, </span>
    
      
      
      [分布式]<span class="sep">, </span>
    
      
      
      [多数派]
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
    <span itemprop="keywords">
    
      
      
      [algo]
    
    </span>
  </p>


        
  <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2020-10-18T00:00:00+08:00">October 18, 2020</time></p>


      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  [<i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span>]

  [<i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span>]

  [<i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span>]
</section>


      
  <nav class="pagination">
    
      [上一页]
    
    
      [下一页]
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">留下评论</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        [slimarray: gzip的压缩率, 即时访问
]
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          15 分钟阅读
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">slimarray 是一个静态整数压缩数组, 现实数据达到和gzip相当的压缩率, 无需解压就可以直接使用
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        [200行代码实现基于paxos的kv存储
]
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          33 分钟阅读
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">用200行代码实现一个基于paxos的kv存储, 以最简洁的形式展示paxos如何运行, 作为 paxos的直观解释 这篇教程中的代码示例部分
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        [可靠分布式系统-paxos的直观解释
]
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 分钟阅读
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">没有paxos的一堆机器, 只能叫做分布式; 有paxos协同才叫分布式系统. 咱得把paxos聊开了聊透了
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        [几个无理取闹的coding心得
]
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          1 分钟阅读
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">来自一个莫得感情的coding万年户
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      输入您要搜索的关键词...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="输入您要搜索的关键词..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->



<script language="javascript" type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/SVG"],
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
        }
    });
</script>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG"> </script>




<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>关注:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <li>[<i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed]</li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 OpenACID-分布式研究小院. 技术来自于 [Jekyll] &amp; [Minimal Mistakes].</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-69976993-2']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>






    
  <script>
    var disqus_config = function () {
      this.page.url = "https://blog.openacid.com/algo/quorum/";  /* Replace PAGE_URL with your page's canonical URL variable */
      this.page.identifier = "/algo/quorum"; /* Replace PAGE_IDENTIFIER with your page's unique identifier variable */
    };
    (function() { /* DON'T EDIT BELOW THIS LINE */
      var d = document, s = d.createElement('script');
      s.src = 'https://openacid.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the [comments powered by Disqus.]</noscript>


  





  <style> .header-link { display: none !important; } </style> </body >
</html>
