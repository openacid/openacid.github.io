<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.17.2 by Michael Rose
  Copyright 2013-2019 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="zh" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Erasure-Code-擦除码-2-实现篇 - OpenACID Blog</title>
<meta name="description" content="书接上回上一篇 第一篇:原理 中, 我们介绍了EC的基本原理,实际上EC的存储跟恢复过程可以理解为:一条k-1次曲线可以通过k个系数或曲线上的点来确定.我们也提到:  但这套理论还不能直接应用到线上产品中.因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,通过Vandermonde矩阵生成校验块, 那校验块的数值几乎确定会溢出.本文我们来解决这个问题, 看如何将EC的理论应用到计算机中, 保证计算不会溢出.  第一篇:原理 上一篇 🤔  第二篇:实现 我们在这 😁  第三篇:极限   🤔思路既然EC的存储过程就是对x取多个不同的值来计算y:恢复的过程是通过已知点的坐标来确定曲线方程:而编码和解码的过程都只需要加减乘除的四则运算(不需要开方),那么, 除了数字之外, 任何对象, 只要能对其进行四则运算,则都可以使用这种方法来实现冗余存储和备份.本文中我们就将通过将数字替换成另一种满足四则运算的东西,来实现计算机上的EC.我们先从简单的例子开始, 打开新世界的大门.  感谢19世纪伟大数学家 伽罗华.本文结构                ==&gt; : 同类概念                ──→ : 概念扩展┌──────────┬─────────────────────────────────────────────────────────┐│          │                                                         ││          │ digits: 0~9          ==&gt;  ┌→ GF(2): ℤ/(2) {0, 1}        ││  finite  │                           │                             ││     ↓    │  ↓                        │   ↓                         ││ infinite │                           │                             ││          │ integer: ℤ           ==&gt;  │  GF(2)[X]:                  ││          │ 10²a₂ + 10¹a₁ + a₀        │  a₂x² + a₁x + a₀            ││ infinite │                           │                             ││     ↓    │  ↓                        │   ↓               Goal!     ││   fixed  │                           │                  ↙          ││          │ GF(7): ℤ/(7) {0..6}  ==&gt;  │  GF(2⁸):  GF(2)[X]/(P₈(X))  ││          │ 5 ⊕ 4 = 2   ──────────────┘  (x+1) + (x) = 1            ││          │ 3 ⊗ 5 = 1                    x¹⁴=x⁴ + x + 1             ││          │                                                         │└──────────┴─────────────────────────────────────────────────────────┘GF(7): 伽罗华域Galois-Field GF(7)上面我们提到的几个数学公式, 高次曲线, 多元一次方程组等,他们之所以能正确的工作, 是因为他们依赖于一套底层的基础运算规则,这就是四则运算:  + - * /这听起来有点废话, 不用四则运算用什么?其实我们平时熟知的四则运算, 并不是唯一的四则运算法则例如在有1种四则运算可能是:5 + 5 = 3 而不是10,5 * 3 = 1 而不是15.栗子4: 只有7个数字的新世界: GF(7)🌰🌰 🌰🌰我们来尝试定义一个新的加法规则, 在这个新的世界里只有0~6这7个数字:其他整数进来时都要被模7, 变成0~6的数字.在这个模7的新世界里, 四则运算也可以工作:模7新世界中的 加法新的加法被表示为 ⊕ (这里原始的加法还是用+来表示):它定义为: a ⊕ b的结果是 a + b后结果再对7取模.例如:1 ⊕ 1 = 2 5 ⊕ 2 = 0 ( 7 % 7 = 0 ) 5 ⊕ 5 = 3 ( 10 % 7 = 3 )在这个新世界里, 0 还是和以前的0很相像, 任何数跟0相加都不变:0 ⊕ 3 = 3 2 ⊕ 0 = 20 在新世界 GF(7) 里被称为加法的单位元.模7新世界中的 减法然后我们再在模7的世界里定义减法.减法的定义也很直接, 就是加法的逆运算了.自然数里, -2 + 2 = 0, 我们称呼-2是2在加法上的逆元(通常称为相反数).在模7的世界里,我们也很容易找到每个数的加法逆元,例如:3 ⊕ 4 = 0所以 4 和 3 就互为加法的逆元.减法定义就是: $ a ⊖ b \rightarrow a ⊕ (-b) $.例如:3 ⊖ 4 = 3 ⊕ (-4) = 3 ⊕ 3 = 6 2 ⊖ 6 = 2 ⊕ (-6) = 2 ⊕ 1 = 3模7新世界中的 乘法 和 除法在模7的新世界里, 我们也可以类似地定义1个乘法:例如:1 ⊗ 5 = 5 ( 5 % 7 = 5 ) 3 ⊗ 4 = 5 ( 12 % 7 = 5 ) 2 ⊗ 5 = 3 ( 10 % 7 = 3 ) 0 ⊗ 6 = 6 ⊗ 0 = 0对于模7新世界的乘法⊗来说, 1 是乘法的单位元,也就是说1 ⊗ 任何数都是它本身.我们也可以用类似的方法定义每个数字在乘法⊗的逆元:a的乘法逆元 a⁻¹ = b, iff a ⊗ b = 1.例如:除法的定义就是: 乘以它的乘法逆元栗子5: 模7新世界直线方程-1🌰🌰 🌰🌰 🌰现在我们有了新的加法和减法⊕, ⊖ 我们可以像使用旧世界的加减法一样来使用⊕, ⊖.例如我们可以建立一个简单的, 斜率为1的直线方程:新世界里这个直线上的点是:(x,y) ∈ [(0,3), (1,4), (2,5), (3,6), (4,0), (5,1), (6,2)]只有7个.如果把这条直线画到坐标系里, 它应该是这个样子的:y = x ⊕ 3  y  ^6 |     •5 |   •4 | •3 •2 |           •1 |         •0 +-------•-----&gt; x  0 1 2 3 4 5 6栗子6: 模7新世界直线方程-2🌰🌰 🌰🌰 🌰🌰再加上新世界加减乘除四则运算, 我们可以在新世界里进行基本的代数运算了,例如我们可以设定1个斜率为2的直线方程:新世界里这个直线上的点是:(x,y) ∈ [(0,3), (1,5), (2,0), (3,2), (4,4), (5,6), (6,1)]这7个.如果把这条直线画到坐标系里, 它应该是这个样子的:y = 2 ⊗ x ⊕ 3  y  ^6 |          •5 | •4 |       •3 •2 |     •1 |           •0 +---•---------&gt; x  0 1 2 3 4 5 6栗子7: 模7新世界中的二次曲线方程🌰🌰 🌰🌰 🌰🌰 🌰下面我们来建立1个稍微复杂1点的, 二次曲线的方程:这里 x² 表示 x ⊗ x新世界里这个抛物线上的点集合是:(x,y) ∈ [(0, 2) (1, 4) (2, 1) (3, 0) (4, 1) (5, 4) (6, 2)]如果把这条抛物线画到坐标系里, 它应该是这个样子的:y = x^2 ⊕ x ⊕ 2  y  ^6 |5 |4 | •       •3 |2 •           •1 |   •   •0 +-----•-------&gt; x  0 1 2 3 4 5 6可以看出它的图像也遵循了旧世界抛物线的特性: 这条抛物线是以3为轴对称的:因为类似旧世界的多项式分解一样, 原方程也可以分解成:GF(7) 的EC实现在这个模7的新世界里, 它满足我们旧世界里的四则运算法则,我们已经可以使用前面(第一篇:原理)提到的 EC 的算法来编码或解码了:假设模7新世界里我们的数据块 d₁ = 3, d₂ = 2, 对应上面的直线方程:y = 2 ⊗ x ⊕ 3我们只要记住直线上2个点的位置, 就能把直线的方程恢复出来, 例如:我们先记录直线上2个点: (1,5) 和 (3,2)假设丢失的数据是 d₁, d₂ 用 u₁, u₂ 表示, 带入2个点的坐标,得到一个二元一次方程组:2个方程左右分别相减消元:最后得到 u₂ = 3 ⊗ 5⁻¹ = 3 ⊗ 3 = 2.将 u₂ = 2 带入第1个方程: 5 = 2 ⊗ 1 ⊕ u₁得到 u₁: u₁ = 5 ⊕ (-2) = 3是不是跟普通的一次方程组解法完全一样!至此, 我们用模7新世界的四则运算实现了之前的 EC . 并且我们保证了校验数据的大小是可控的:不会大于7!距离我们的目标又接近了1步.模7下的四则运算构成了1个 伽罗华域 Galois-Field: GF(7).简单来说, Galois-Field 是一个集合, 集合里的元素满足某种四则运算.摘自wikipedia上的解释:  A finite field is a set on which the operations of multiplication, addition, subtraction and division are defined  7是1个可选的数来通过取模的方式构造一个Galois-Field,也可以选择模11或其他质数来构造1个 Galois-Field,但是不能选择模一个合数来建立新的四则运算规则.假设使用模6, 模6世界里面的2是6的一个因子, 它没有乘法逆元, 也即是说2 乘以1~5任何一个数在模6的世界里都不是1.  没有乘法逆元就说明模6的世界里没有和旧世界里一样的除法,不能构成一个完整的四则运算体系.  为了简化, 四则里还有几个方面没有提到, 例如乘法加法的分配率.乘法和加法的结合律也必须满足, 才能在新世界里实现上面例子中的曲线方程等元素.这部分也很容验证,在上面的模7新世界里是可以满足的.现在我们有了 EC 的算法,以及很多个可以选择的四则运算来限定数值的范围.接下来要在计算机上实现,还有1步,就是:模7虽然可取,但是它没有办法对计算机里的数字有效利用,因为计算机里的数是二进制的.如果把数值限定到7或其他质数上,没有办法实现256或65536这样的区间的有效利用.所以接下来我们需要在所有四则运算里选择一个符合计算机的二进制的四则运算,作为实现 EC 计算的基础代数结构.从现在开始, 我们要构造一个现实中可用的伽罗华域,它比上面模7新世界稍微复杂一点, 得到这个域分为2步:      我们首先选择1个基础的,只包含2个元素的 Galois-Field GF(2): {0, 1}.        再在这个 GF(2) 的基础上建立1个有256个元素的 Galois-Field GF(2⁸).  GF(2): 模2的新世界: Galois-Field GF(2)首先选择了最小的Galois-Field GF(2), 类似于前面模7的例子, GF(2) 里的四则运算的定义为结果模2.它里面只有2个元素{0,1}:在这个GF(2)里, 运算的规则也非常简单:      加法(刚好和位运算的异或等价):    0 ⊕ 0 = 00 ⊕ 1 = 11 ⊕ 0 = 11 ⊕ 1 = 0        1的加法逆元就是1 本身.        乘法(刚好和位运算的与等价):    0 ⊗ 0 = 00 ⊗ 1 = 01 ⊗ 0 = 01 ⊗ 1 = 1        1的乘法逆元就是1 本身. 0 没有乘法逆元.  以这个GF(2)为基础, 可以构建一个1-bit的 EC 算法了:)  后面的讨论全部是依赖于GF(2)中的加法和乘法, 为了看起来清楚, 不再使用⊕和⊗了,直接使用传统的+, *来表示.GF(2) 的EC实现假设要存储的数据是:d₁ = 1, d₂ = 1对应直线方程是:y = 1 + x取2个点: x₁ = 0, x₂ = 1得到2个校验数据的值:y₁ = 1 + 0 = 1 y₂ = 1 + 1 = 0数据丢失后, 通过2个点的坐标找回直线方程系数:解得 u₁ = 1, u₂ = 1.下一步, 我们希望构建1个1 byte大小(2⁸ 个元素)的 Galois-Field GF(2⁸),在这个 GF(2⁸) 里的 EC 中,每个 dⱼ  和  yᵢ 的取值范围可以是0~255.但首先我们需要能表示比GF(2)更多的值.GF(2)[X] : GF(2) 作为系数的多项式类似于我们只需要0~9这10个自然数, 就可以通过增加进位这个概念后, 扩展成能表示任意大小的10进制整数一样(或用0~7表示任意大小的8进制数),我们通过类似的方法扩展{0,1}这2个数字, 表示更多的信息.引入多项式:使用 GF(2) 的元素作为系数, 定义1个多项式:系数 aᵢ 的四则运算还是遵循 GF(2) 的规则的,而多项式的四则运算, 显然是基于它的系数的四则运算建立的.例如多项式的加法:      因为 1 + 1 = 0, 所以: (x + 1) + (1) = x        x的同指数幂的系数相加遵循系数的Field的加法规则, 1 + 1 = 0:    (x² + x + 1) + (x) = x² + 1        2个相同的多项式相加肯定是0:    (x² + x + 1) + (x² + x + 1) = 0  多项式的乘法和旧世界的多项式乘法类似, 仍然是通过乘法的分配率展开多项式:多项式的除法依旧使用旧世界的多项式长除法法则,唯一不同仍旧是系数的四则运算是基于GF(2)的, 例如:多项式的除法的取余计算也类似, 因为 x² + x + 1 = x (x+1) + 1,所以: (x² + x + 1) = 1 mod (x+1) .我们看到, 多项式之间也是满足加减乘除四则运算的!  现在我们已经接触到了3种不同的四则运算:  GF(2)中元素的四则运算.GF(7)中元素的四则运算.GF(2) 多项式的四则运算.也就是说我们可以建议一个备份和恢复多项式的EC:GF(2)[X]的EC实现通过一个简单的例子来构建一个存储2个多项式的EC,将要存储的2个多项式作为系数建议一个直线:例如要存储的2个多项式 p₁ = x² + 1, p₂ = x,取直线上2个点, 例如X₁ X₂ 分别取1, x,代入直线方程得到2个Y的值:      存储过程:存储 p₁,  p₂, Y₁ Y₂;也就是: (x² + 1, x, x² + x + 1, 1)        恢复过程:假设 p₁, p₂ 都丢了,我们可以把Y₁, Y₂代入, 把p₁, p₂作为未知数建立一个方程组:  通过消元解方程, 两个方程相减, 恢复出p₂:这样我们就实现了一个基于多项式的EC了.但多项式的乘法依旧是有越界的问题的,如果自然数到模7的方法一样,我们需要把多项式的四则运算通过取模, 约束到一个可控的范围内.还是取模!GF(2⁸)GF(2)为系数的多项式的集合还不是一个伽罗华域,因为缺少除法逆元. 就像整数全集也不是一个伽罗华域,它也缺少除法逆元.  但在上面我们使用GF(2)的多项式来实现EC时, 没有触碰到没有乘法逆元这个问题.就像可以用2个整数作为分子分母来表示分数一样,用这种复合形式表示一个不存在的元素进行中间步骤的计算.  例如½不在整数集合, 但可以用1和2两个整数来表示出来.  而计算的最终结果都是恢复已存在的值, 所以分数形式的多项式最终都会被消去.但这种分数形式的表示方法在实际使用中会造成很大不便.现在我们需要找到1个质的多项式(Prime-Polynomial),来替代GF(7)中7的角色,最终得到1个有256个元素的多项式的伽罗华域 GF(2⁸).GF(2⁸) 类似于模7的方式, 将多项式模一个质的多项式(Prime-Polynomial)来得到:GF(2)[X]/(P₈(X))质的多项式(Prime-Polynomial) 简单说就是不可分解的多项式,例如 x² + 1 在实数域下就是 质多项式, 它无法分解成2个多项式乘积.GF(2) 下的质多项式      1 是1个质多项式.        x + 1 是1个质多项式.因为它最高次幂是1, 肯定不能再拆分成2个多项式乘积了.把所有GF(2)下的多项式对x + 1 取模, 只有2个可能的值: 0, 1.        x² + 1 不是一个质多项式, 它可以分解成(x + 1)².        2次的质多项式是: P₂(x) = x² + x + 1 .它在GF(2)的域中不能被拆分成2个1次多项式的乘积.    我们可以像使用7对所有整数取模那样, 用它对所有多项式取模,模它而产生的所有 余多项式, 是所有最高次幂小于2的多项式, 共有4个:0, 1, x, (x + 1).    模P₂(x)的多项式集合里, 同样满足多项式的四则运算.    对于其他j次幂的质多项式 Pⱼ(x),模Pⱼ(x)的多项式集合里, 也刚好有2ʲ 个元素.  GF(2) 扩张成 GF(2⁸)为了扩张到 GF(2⁸) 我们选择的8次幂的质多项式是:P₈(x) = x⁸ + x⁴ + x³ + x² + 1这个8次幂的质多项式,模它的所有余多项式,是所有最高次幂不超过7的多项式, 共256个,它就是 GF(2) 到 GF(2⁸) 的扩张.  Field-Extension 域的扩张, 简单来说就是通过把一个域(例如GF(2)),作为系数构建多项式, 再去模一个质多项式(如P₈(x)), 得到的余多项式集合(例如GF(2⁸)).  这里从一个2个数字的集合GF(2), 扩张之后得到的却是一个多项式的集合,因为在伽罗瓦的理论里, 数字跟多项式是没有区别的,因为他们都可以进行四则运算.就像我们前面也可以把多项式作为直线方程的系数一样.然后我们还发现, 因为多项式的系数是GF(2)下的元素, 只能是0或1.于是 这些多项式和二进制数是有一一对应关系的,多项式中指数为i的项的系数就是二进制数第i位的值:扩张后的元素对应0~255这256个二进制数, P₈(x) 对应:  二进制: 1 0001 1101  16进制: 0x11d而GF(2⁸)中的四则运算如下:      加法:a ⊕ b 对应多项式加法,同时它表示的二进制数的加法对应: a ^ b        乘法:a ⊗ b 对应多项式的乘法(模P₈(x)):  总结一下GF(2⁸)能够满足EC运算的几个性质:  加法单位元: 0  乘法单位元: 1  每个元素对加法都有逆元(可以实现减法): 逆元就是它本身( (x+1) + (x+1) = 0 )  每个元素对乘法都有逆元(除了0)(可以实现除法):P₈(x)是不可约的,因此不存在a和b都不是0但ab=0;又因为GF(2⁸)只有255个非0元素,因此对a,总能找到1个x使得 aˣ = a . 所以 aˣ⁻² a = 1.  aˣ⁻² 是a的乘法逆元.          PS, 看到 aˣ = a 是不是想起了费马小定理? :) 费马小定理的群论的证明        乘法和加法满足分配率: 基于多项式乘法和加法的定义.满足这些性质的四则运算, 就可以用GF(2⁸)来建立高次曲线, 进而在GF(2⁸)上实现EC.标准EC的实现以上讨论的是标准的EC的原理, 现在我们将以上的内容总结, 应用到实践上面.      标准的EC实现是基于GF(2)[X]/P(x), 一般基于 GF(2⁸) 或 GF(2¹⁶), GF(2³²), 分别对应1字节,2字节或4字节. 最常见的是GF(2⁸).        GF(2⁸) 下的加减法直接用异或计算, 不需要其他的工作.        GF(2⁸) 下的乘法和除法用查表的方式实现.    首先生成 GF(2⁸) 下对2的指数表和对数表,然后把乘除法转换成取对数和取幂的操作:    以 GF(2⁸) 为例:                  生成指数表 2⁰, 2¹, 2²… 的表,表中元素 pᵢ = 2^i.                    生成对数表, 表中元素 lᵢ = log₂i.              生成2个表的代码很简单, 用python表示如下:    power, log = [0] * 256, [0] * 256n = 1for i in range(0, 256):    power[i] = n    log[n] = i    n *= 2    # modular by the prime polynomial: P₈(x) = x⁸ + x⁴ + x³ + x² + 1    if n &gt;= 256:        n = n ^ 0x11dlog[1] = 0 # log[1] is 255, but it should be 0        指数表:01 02 04 08 10 20 40 80 1d 3a 74 e8 cd 87 13 264c 98 2d 5a b4 75 ea c9 8f 03 06 0c 18 30 60 c09d 27 4e 9c 25 4a 94 35 6a d4 b5 77 ee c1 9f 2346 8c 05 0a 14 28 50 a0 5d ba 69 d2 b9 6f de a15f be 61 c2 99 2f 5e bc 65 ca 89 0f 1e 3c 78 f0fd e7 d3 bb 6b d6 b1 7f fe e1 df a3 5b b6 71 e2d9 af 43 86 11 22 44 88 0d 1a 34 68 d0 bd 67 ce81 1f 3e 7c f8 ed c7 93 3b 76 ec c5 97 33 66 cc85 17 2e 5c b8 6d da a9 4f 9e 21 42 84 15 2a 54a8 4d 9a 29 52 a4 55 aa 49 92 39 72 e4 d5 b7 73e6 d1 bf 63 c6 91 3f 7e fc e5 d7 b3 7b f6 f1 ffe3 db ab 4b 96 31 62 c4 95 37 6e dc a5 57 ae 4182 19 32 64 c8 8d 07 0e 1c 38 70 e0 dd a7 53 a651 a2 59 b2 79 f2 f9 ef c3 9b 2b 56 ac 45 8a 0912 24 48 90 3d 7a f4 f5 f7 f3 fb eb cb 8b 0b 162c 58 b0 7d fa e9 cf 83 1b 36 6c d8 ad 47 8e 01        对数表(0没有以2为底的对数):00 00 01 19 02 32 1a c6 03 df 33 ee 1b 68 c7 4b04 64 e0 0e 34 8d ef 81 1c c1 69 f8 c8 08 4c 7105 8a 65 2f e1 24 0f 21 35 93 8e da f0 12 82 451d b5 c2 7d 6a 27 f9 b9 c9 9a 09 78 4d e4 72 a606 bf 8b 62 66 dd 30 fd e2 98 25 b3 10 91 22 8836 d0 94 ce 8f 96 db bd f1 d2 13 5c 83 38 46 401e 42 b6 a3 c3 48 7e 6e 6b 3a 28 54 fa 85 ba 3dca 5e 9b 9f 0a 15 79 2b 4e d4 e5 ac 73 f3 a7 5707 70 c0 f7 8c 80 63 0d 67 4a de ed 31 c5 fe 18e3 a5 99 77 26 b8 b4 7c 11 44 92 d9 23 20 89 2e37 3f d1 5b 95 bc cf cd 90 87 97 b2 dc fc be 61f2 56 d3 ab 14 2a 5d 9e 84 3c 39 53 47 6d 41 a21f 2d 43 d8 b7 7b a4 76 c4 17 49 ec 7f 0c 6f f66c a1 3b 52 29 9d 55 aa fb 60 86 b1 bb cc 3e 5acb 59 5f b0 9c a9 a0 51 0b f5 16 eb 7a 75 2c d74f ae d5 e9 e6 e7 ad e8 74 d6 f4 ea a8 50 58 af        在计算 GF(2⁸) 中的乘法将 a, b 通过查对数表和指数表实现:              Galois-Field 的计算目前实现都是基于查表的,所以选择大的域虽然可以一次计算多个字节,但内存中随机访问一个大表也可能会造成cache miss太多而影响性能.              一般CPU都没有支持GF乘除法的指令, 但有些专用的硬件卡专门加速GF的乘除法.最新的CPU 逐渐开始加入GF乘除法支持了.      有了加减乘除的计算支持, 下一步就是实现EC的编解码.EC编码: 校验数据生成通常使用1个矩阵来表示输入和输出的关系(而不是像上文中只使用校验块的生成矩阵),这里选择1, 2, 3..生成的 Vandermonde 矩阵:这个矩阵里上面是1个大小为k的单位矩阵, 表示 dⱼ 的输入和输出不变.下面一部分是1个 m * k 的矩阵表示校验块的计算.对要存储的k组数据, 逐字节读入, 形成 d₁, d₂… , 进行矩阵乘法运算,得到最后要存储的 k 个数据块和 m 个校验块.  之所以把单位矩阵也放到编码矩阵上面, 看起来没有什么用,只是把输入无变化的输出出来的这种风格, 原因在于在编码理论中,并不是所有的生成的Code都是k个原始数据 和 m个校验数据的形式,有些编码算法是将k个输入变成完全不1样的k+m个输出, 对这类编码算法,需要1个k*(k+m)的编码矩阵来表示全部的转换过程.例如著名的 Hamming-7-4 编码的编码矩阵(输入k=4, 输出k+m=7):  EC解码当数据损坏时, 通过生成解码矩阵来恢复数据:对所有丢失的数据,将它对应的第i行从编码矩阵中移除,移除后, 保留编码矩阵的前k行,构成1个k*k的矩阵.例如第 2, 3个数据块丢失, 移除第2, 3行, 保留第k+1和k+2行:这时矩阵中数据块和校验块的关系是:最后求逆矩阵, 和没有丢失的块相乘, 就可以恢复出丢失的数据块 u₂, u₃:因为只有 u₂, u₃ 丢失了, 矩阵相乘时只需要计算逆矩阵的第2, 3行.Vandermonde 矩阵的可逆性在 第一篇:原理 中通提到:  Vandermonde 矩阵的任意 m * m 的子矩阵, 是一个Generalized Vandermonde Matrix, 它在 xᵢ 都为正数时可以保证永远有唯一解.但在GF(2⁸) 中不成立.举例来说, 以下矩阵是缺失 u₁, u₄ 情况下的用来恢复数据的矩阵,如果 x³ == 1, 它就不可逆.由于2是1个生成元,  容易看出, x = 2⁸⁵ 是1个不可逆的情况:x³ = 1 于是第1列和第4列完全一样.Cauchy 矩阵的可逆性  Cauchy 矩阵的任意n行n列组成的矩阵都是可逆的, 因为任意子矩阵还是 Cauchy矩阵.EC的实现到这里就结束了,有了GF(2⁸)的四则运算实现后, 再通过牛顿消元实现逆矩阵的求解,就可以完整的实现出一套EC算法了.在EC的计算中, 编解码是一个比较耗时的过程,因此业界也在不断寻找优化的方法, 不论从理论算法上还是从计算机指令的优化上,于是下一篇我们将介绍如何把EC实现为一个高效的实现.  EC擦除码系列:      第一篇:原理    第二篇:实现    第三篇:极限  ">


  <meta name="author" content="张炎泼(xp)">


<meta property="og:type" content="article">
<meta property="og:locale" content="zh_CN">
<meta property="og:site_name" content="OpenACID Blog">
<meta property="og:title" content="Erasure-Code-擦除码-2-实现篇">
<meta property="og:url" content="https://blog.openacid.com/storage/ec-2/">


  <meta property="og:description" content="书接上回上一篇 第一篇:原理 中, 我们介绍了EC的基本原理,实际上EC的存储跟恢复过程可以理解为:一条k-1次曲线可以通过k个系数或曲线上的点来确定.我们也提到:  但这套理论还不能直接应用到线上产品中.因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,通过Vandermonde矩阵生成校验块, 那校验块的数值几乎确定会溢出.本文我们来解决这个问题, 看如何将EC的理论应用到计算机中, 保证计算不会溢出.  第一篇:原理 上一篇 🤔  第二篇:实现 我们在这 😁  第三篇:极限   🤔思路既然EC的存储过程就是对x取多个不同的值来计算y:恢复的过程是通过已知点的坐标来确定曲线方程:而编码和解码的过程都只需要加减乘除的四则运算(不需要开方),那么, 除了数字之外, 任何对象, 只要能对其进行四则运算,则都可以使用这种方法来实现冗余存储和备份.本文中我们就将通过将数字替换成另一种满足四则运算的东西,来实现计算机上的EC.我们先从简单的例子开始, 打开新世界的大门.  感谢19世纪伟大数学家 伽罗华.本文结构                ==&gt; : 同类概念                ──→ : 概念扩展┌──────────┬─────────────────────────────────────────────────────────┐│          │                                                         ││          │ digits: 0~9          ==&gt;  ┌→ GF(2): ℤ/(2) {0, 1}        ││  finite  │                           │                             ││     ↓    │  ↓                        │   ↓                         ││ infinite │                           │                             ││          │ integer: ℤ           ==&gt;  │  GF(2)[X]:                  ││          │ 10²a₂ + 10¹a₁ + a₀        │  a₂x² + a₁x + a₀            ││ infinite │                           │                             ││     ↓    │  ↓                        │   ↓               Goal!     ││   fixed  │                           │                  ↙          ││          │ GF(7): ℤ/(7) {0..6}  ==&gt;  │  GF(2⁸):  GF(2)[X]/(P₈(X))  ││          │ 5 ⊕ 4 = 2   ──────────────┘  (x+1) + (x) = 1            ││          │ 3 ⊗ 5 = 1                    x¹⁴=x⁴ + x + 1             ││          │                                                         │└──────────┴─────────────────────────────────────────────────────────┘GF(7): 伽罗华域Galois-Field GF(7)上面我们提到的几个数学公式, 高次曲线, 多元一次方程组等,他们之所以能正确的工作, 是因为他们依赖于一套底层的基础运算规则,这就是四则运算:  + - * /这听起来有点废话, 不用四则运算用什么?其实我们平时熟知的四则运算, 并不是唯一的四则运算法则例如在有1种四则运算可能是:5 + 5 = 3 而不是10,5 * 3 = 1 而不是15.栗子4: 只有7个数字的新世界: GF(7)🌰🌰 🌰🌰我们来尝试定义一个新的加法规则, 在这个新的世界里只有0~6这7个数字:其他整数进来时都要被模7, 变成0~6的数字.在这个模7的新世界里, 四则运算也可以工作:模7新世界中的 加法新的加法被表示为 ⊕ (这里原始的加法还是用+来表示):它定义为: a ⊕ b的结果是 a + b后结果再对7取模.例如:1 ⊕ 1 = 2 5 ⊕ 2 = 0 ( 7 % 7 = 0 ) 5 ⊕ 5 = 3 ( 10 % 7 = 3 )在这个新世界里, 0 还是和以前的0很相像, 任何数跟0相加都不变:0 ⊕ 3 = 3 2 ⊕ 0 = 20 在新世界 GF(7) 里被称为加法的单位元.模7新世界中的 减法然后我们再在模7的世界里定义减法.减法的定义也很直接, 就是加法的逆运算了.自然数里, -2 + 2 = 0, 我们称呼-2是2在加法上的逆元(通常称为相反数).在模7的世界里,我们也很容易找到每个数的加法逆元,例如:3 ⊕ 4 = 0所以 4 和 3 就互为加法的逆元.减法定义就是: $ a ⊖ b \rightarrow a ⊕ (-b) $.例如:3 ⊖ 4 = 3 ⊕ (-4) = 3 ⊕ 3 = 6 2 ⊖ 6 = 2 ⊕ (-6) = 2 ⊕ 1 = 3模7新世界中的 乘法 和 除法在模7的新世界里, 我们也可以类似地定义1个乘法:例如:1 ⊗ 5 = 5 ( 5 % 7 = 5 ) 3 ⊗ 4 = 5 ( 12 % 7 = 5 ) 2 ⊗ 5 = 3 ( 10 % 7 = 3 ) 0 ⊗ 6 = 6 ⊗ 0 = 0对于模7新世界的乘法⊗来说, 1 是乘法的单位元,也就是说1 ⊗ 任何数都是它本身.我们也可以用类似的方法定义每个数字在乘法⊗的逆元:a的乘法逆元 a⁻¹ = b, iff a ⊗ b = 1.例如:除法的定义就是: 乘以它的乘法逆元栗子5: 模7新世界直线方程-1🌰🌰 🌰🌰 🌰现在我们有了新的加法和减法⊕, ⊖ 我们可以像使用旧世界的加减法一样来使用⊕, ⊖.例如我们可以建立一个简单的, 斜率为1的直线方程:新世界里这个直线上的点是:(x,y) ∈ [(0,3), (1,4), (2,5), (3,6), (4,0), (5,1), (6,2)]只有7个.如果把这条直线画到坐标系里, 它应该是这个样子的:y = x ⊕ 3  y  ^6 |     •5 |   •4 | •3 •2 |           •1 |         •0 +-------•-----&gt; x  0 1 2 3 4 5 6栗子6: 模7新世界直线方程-2🌰🌰 🌰🌰 🌰🌰再加上新世界加减乘除四则运算, 我们可以在新世界里进行基本的代数运算了,例如我们可以设定1个斜率为2的直线方程:新世界里这个直线上的点是:(x,y) ∈ [(0,3), (1,5), (2,0), (3,2), (4,4), (5,6), (6,1)]这7个.如果把这条直线画到坐标系里, 它应该是这个样子的:y = 2 ⊗ x ⊕ 3  y  ^6 |          •5 | •4 |       •3 •2 |     •1 |           •0 +---•---------&gt; x  0 1 2 3 4 5 6栗子7: 模7新世界中的二次曲线方程🌰🌰 🌰🌰 🌰🌰 🌰下面我们来建立1个稍微复杂1点的, 二次曲线的方程:这里 x² 表示 x ⊗ x新世界里这个抛物线上的点集合是:(x,y) ∈ [(0, 2) (1, 4) (2, 1) (3, 0) (4, 1) (5, 4) (6, 2)]如果把这条抛物线画到坐标系里, 它应该是这个样子的:y = x^2 ⊕ x ⊕ 2  y  ^6 |5 |4 | •       •3 |2 •           •1 |   •   •0 +-----•-------&gt; x  0 1 2 3 4 5 6可以看出它的图像也遵循了旧世界抛物线的特性: 这条抛物线是以3为轴对称的:因为类似旧世界的多项式分解一样, 原方程也可以分解成:GF(7) 的EC实现在这个模7的新世界里, 它满足我们旧世界里的四则运算法则,我们已经可以使用前面(第一篇:原理)提到的 EC 的算法来编码或解码了:假设模7新世界里我们的数据块 d₁ = 3, d₂ = 2, 对应上面的直线方程:y = 2 ⊗ x ⊕ 3我们只要记住直线上2个点的位置, 就能把直线的方程恢复出来, 例如:我们先记录直线上2个点: (1,5) 和 (3,2)假设丢失的数据是 d₁, d₂ 用 u₁, u₂ 表示, 带入2个点的坐标,得到一个二元一次方程组:2个方程左右分别相减消元:最后得到 u₂ = 3 ⊗ 5⁻¹ = 3 ⊗ 3 = 2.将 u₂ = 2 带入第1个方程: 5 = 2 ⊗ 1 ⊕ u₁得到 u₁: u₁ = 5 ⊕ (-2) = 3是不是跟普通的一次方程组解法完全一样!至此, 我们用模7新世界的四则运算实现了之前的 EC . 并且我们保证了校验数据的大小是可控的:不会大于7!距离我们的目标又接近了1步.模7下的四则运算构成了1个 伽罗华域 Galois-Field: GF(7).简单来说, Galois-Field 是一个集合, 集合里的元素满足某种四则运算.摘自wikipedia上的解释:  A finite field is a set on which the operations of multiplication, addition, subtraction and division are defined  7是1个可选的数来通过取模的方式构造一个Galois-Field,也可以选择模11或其他质数来构造1个 Galois-Field,但是不能选择模一个合数来建立新的四则运算规则.假设使用模6, 模6世界里面的2是6的一个因子, 它没有乘法逆元, 也即是说2 乘以1~5任何一个数在模6的世界里都不是1.  没有乘法逆元就说明模6的世界里没有和旧世界里一样的除法,不能构成一个完整的四则运算体系.  为了简化, 四则里还有几个方面没有提到, 例如乘法加法的分配率.乘法和加法的结合律也必须满足, 才能在新世界里实现上面例子中的曲线方程等元素.这部分也很容验证,在上面的模7新世界里是可以满足的.现在我们有了 EC 的算法,以及很多个可以选择的四则运算来限定数值的范围.接下来要在计算机上实现,还有1步,就是:模7虽然可取,但是它没有办法对计算机里的数字有效利用,因为计算机里的数是二进制的.如果把数值限定到7或其他质数上,没有办法实现256或65536这样的区间的有效利用.所以接下来我们需要在所有四则运算里选择一个符合计算机的二进制的四则运算,作为实现 EC 计算的基础代数结构.从现在开始, 我们要构造一个现实中可用的伽罗华域,它比上面模7新世界稍微复杂一点, 得到这个域分为2步:      我们首先选择1个基础的,只包含2个元素的 Galois-Field GF(2): {0, 1}.        再在这个 GF(2) 的基础上建立1个有256个元素的 Galois-Field GF(2⁸).  GF(2): 模2的新世界: Galois-Field GF(2)首先选择了最小的Galois-Field GF(2), 类似于前面模7的例子, GF(2) 里的四则运算的定义为结果模2.它里面只有2个元素{0,1}:在这个GF(2)里, 运算的规则也非常简单:      加法(刚好和位运算的异或等价):    0 ⊕ 0 = 00 ⊕ 1 = 11 ⊕ 0 = 11 ⊕ 1 = 0        1的加法逆元就是1 本身.        乘法(刚好和位运算的与等价):    0 ⊗ 0 = 00 ⊗ 1 = 01 ⊗ 0 = 01 ⊗ 1 = 1        1的乘法逆元就是1 本身. 0 没有乘法逆元.  以这个GF(2)为基础, 可以构建一个1-bit的 EC 算法了:)  后面的讨论全部是依赖于GF(2)中的加法和乘法, 为了看起来清楚, 不再使用⊕和⊗了,直接使用传统的+, *来表示.GF(2) 的EC实现假设要存储的数据是:d₁ = 1, d₂ = 1对应直线方程是:y = 1 + x取2个点: x₁ = 0, x₂ = 1得到2个校验数据的值:y₁ = 1 + 0 = 1 y₂ = 1 + 1 = 0数据丢失后, 通过2个点的坐标找回直线方程系数:解得 u₁ = 1, u₂ = 1.下一步, 我们希望构建1个1 byte大小(2⁸ 个元素)的 Galois-Field GF(2⁸),在这个 GF(2⁸) 里的 EC 中,每个 dⱼ  和  yᵢ 的取值范围可以是0~255.但首先我们需要能表示比GF(2)更多的值.GF(2)[X] : GF(2) 作为系数的多项式类似于我们只需要0~9这10个自然数, 就可以通过增加进位这个概念后, 扩展成能表示任意大小的10进制整数一样(或用0~7表示任意大小的8进制数),我们通过类似的方法扩展{0,1}这2个数字, 表示更多的信息.引入多项式:使用 GF(2) 的元素作为系数, 定义1个多项式:系数 aᵢ 的四则运算还是遵循 GF(2) 的规则的,而多项式的四则运算, 显然是基于它的系数的四则运算建立的.例如多项式的加法:      因为 1 + 1 = 0, 所以: (x + 1) + (1) = x        x的同指数幂的系数相加遵循系数的Field的加法规则, 1 + 1 = 0:    (x² + x + 1) + (x) = x² + 1        2个相同的多项式相加肯定是0:    (x² + x + 1) + (x² + x + 1) = 0  多项式的乘法和旧世界的多项式乘法类似, 仍然是通过乘法的分配率展开多项式:多项式的除法依旧使用旧世界的多项式长除法法则,唯一不同仍旧是系数的四则运算是基于GF(2)的, 例如:多项式的除法的取余计算也类似, 因为 x² + x + 1 = x (x+1) + 1,所以: (x² + x + 1) = 1 mod (x+1) .我们看到, 多项式之间也是满足加减乘除四则运算的!  现在我们已经接触到了3种不同的四则运算:  GF(2)中元素的四则运算.GF(7)中元素的四则运算.GF(2) 多项式的四则运算.也就是说我们可以建议一个备份和恢复多项式的EC:GF(2)[X]的EC实现通过一个简单的例子来构建一个存储2个多项式的EC,将要存储的2个多项式作为系数建议一个直线:例如要存储的2个多项式 p₁ = x² + 1, p₂ = x,取直线上2个点, 例如X₁ X₂ 分别取1, x,代入直线方程得到2个Y的值:      存储过程:存储 p₁,  p₂, Y₁ Y₂;也就是: (x² + 1, x, x² + x + 1, 1)        恢复过程:假设 p₁, p₂ 都丢了,我们可以把Y₁, Y₂代入, 把p₁, p₂作为未知数建立一个方程组:  通过消元解方程, 两个方程相减, 恢复出p₂:这样我们就实现了一个基于多项式的EC了.但多项式的乘法依旧是有越界的问题的,如果自然数到模7的方法一样,我们需要把多项式的四则运算通过取模, 约束到一个可控的范围内.还是取模!GF(2⁸)GF(2)为系数的多项式的集合还不是一个伽罗华域,因为缺少除法逆元. 就像整数全集也不是一个伽罗华域,它也缺少除法逆元.  但在上面我们使用GF(2)的多项式来实现EC时, 没有触碰到没有乘法逆元这个问题.就像可以用2个整数作为分子分母来表示分数一样,用这种复合形式表示一个不存在的元素进行中间步骤的计算.  例如½不在整数集合, 但可以用1和2两个整数来表示出来.  而计算的最终结果都是恢复已存在的值, 所以分数形式的多项式最终都会被消去.但这种分数形式的表示方法在实际使用中会造成很大不便.现在我们需要找到1个质的多项式(Prime-Polynomial),来替代GF(7)中7的角色,最终得到1个有256个元素的多项式的伽罗华域 GF(2⁸).GF(2⁸) 类似于模7的方式, 将多项式模一个质的多项式(Prime-Polynomial)来得到:GF(2)[X]/(P₈(X))质的多项式(Prime-Polynomial) 简单说就是不可分解的多项式,例如 x² + 1 在实数域下就是 质多项式, 它无法分解成2个多项式乘积.GF(2) 下的质多项式      1 是1个质多项式.        x + 1 是1个质多项式.因为它最高次幂是1, 肯定不能再拆分成2个多项式乘积了.把所有GF(2)下的多项式对x + 1 取模, 只有2个可能的值: 0, 1.        x² + 1 不是一个质多项式, 它可以分解成(x + 1)².        2次的质多项式是: P₂(x) = x² + x + 1 .它在GF(2)的域中不能被拆分成2个1次多项式的乘积.    我们可以像使用7对所有整数取模那样, 用它对所有多项式取模,模它而产生的所有 余多项式, 是所有最高次幂小于2的多项式, 共有4个:0, 1, x, (x + 1).    模P₂(x)的多项式集合里, 同样满足多项式的四则运算.    对于其他j次幂的质多项式 Pⱼ(x),模Pⱼ(x)的多项式集合里, 也刚好有2ʲ 个元素.  GF(2) 扩张成 GF(2⁸)为了扩张到 GF(2⁸) 我们选择的8次幂的质多项式是:P₈(x) = x⁸ + x⁴ + x³ + x² + 1这个8次幂的质多项式,模它的所有余多项式,是所有最高次幂不超过7的多项式, 共256个,它就是 GF(2) 到 GF(2⁸) 的扩张.  Field-Extension 域的扩张, 简单来说就是通过把一个域(例如GF(2)),作为系数构建多项式, 再去模一个质多项式(如P₈(x)), 得到的余多项式集合(例如GF(2⁸)).  这里从一个2个数字的集合GF(2), 扩张之后得到的却是一个多项式的集合,因为在伽罗瓦的理论里, 数字跟多项式是没有区别的,因为他们都可以进行四则运算.就像我们前面也可以把多项式作为直线方程的系数一样.然后我们还发现, 因为多项式的系数是GF(2)下的元素, 只能是0或1.于是 这些多项式和二进制数是有一一对应关系的,多项式中指数为i的项的系数就是二进制数第i位的值:扩张后的元素对应0~255这256个二进制数, P₈(x) 对应:  二进制: 1 0001 1101  16进制: 0x11d而GF(2⁸)中的四则运算如下:      加法:a ⊕ b 对应多项式加法,同时它表示的二进制数的加法对应: a ^ b        乘法:a ⊗ b 对应多项式的乘法(模P₈(x)):  总结一下GF(2⁸)能够满足EC运算的几个性质:  加法单位元: 0  乘法单位元: 1  每个元素对加法都有逆元(可以实现减法): 逆元就是它本身( (x+1) + (x+1) = 0 )  每个元素对乘法都有逆元(除了0)(可以实现除法):P₈(x)是不可约的,因此不存在a和b都不是0但ab=0;又因为GF(2⁸)只有255个非0元素,因此对a,总能找到1个x使得 aˣ = a . 所以 aˣ⁻² a = 1.  aˣ⁻² 是a的乘法逆元.          PS, 看到 aˣ = a 是不是想起了费马小定理? :) 费马小定理的群论的证明        乘法和加法满足分配率: 基于多项式乘法和加法的定义.满足这些性质的四则运算, 就可以用GF(2⁸)来建立高次曲线, 进而在GF(2⁸)上实现EC.标准EC的实现以上讨论的是标准的EC的原理, 现在我们将以上的内容总结, 应用到实践上面.      标准的EC实现是基于GF(2)[X]/P(x), 一般基于 GF(2⁸) 或 GF(2¹⁶), GF(2³²), 分别对应1字节,2字节或4字节. 最常见的是GF(2⁸).        GF(2⁸) 下的加减法直接用异或计算, 不需要其他的工作.        GF(2⁸) 下的乘法和除法用查表的方式实现.    首先生成 GF(2⁸) 下对2的指数表和对数表,然后把乘除法转换成取对数和取幂的操作:    以 GF(2⁸) 为例:                  生成指数表 2⁰, 2¹, 2²… 的表,表中元素 pᵢ = 2^i.                    生成对数表, 表中元素 lᵢ = log₂i.              生成2个表的代码很简单, 用python表示如下:    power, log = [0] * 256, [0] * 256n = 1for i in range(0, 256):    power[i] = n    log[n] = i    n *= 2    # modular by the prime polynomial: P₈(x) = x⁸ + x⁴ + x³ + x² + 1    if n &gt;= 256:        n = n ^ 0x11dlog[1] = 0 # log[1] is 255, but it should be 0        指数表:01 02 04 08 10 20 40 80 1d 3a 74 e8 cd 87 13 264c 98 2d 5a b4 75 ea c9 8f 03 06 0c 18 30 60 c09d 27 4e 9c 25 4a 94 35 6a d4 b5 77 ee c1 9f 2346 8c 05 0a 14 28 50 a0 5d ba 69 d2 b9 6f de a15f be 61 c2 99 2f 5e bc 65 ca 89 0f 1e 3c 78 f0fd e7 d3 bb 6b d6 b1 7f fe e1 df a3 5b b6 71 e2d9 af 43 86 11 22 44 88 0d 1a 34 68 d0 bd 67 ce81 1f 3e 7c f8 ed c7 93 3b 76 ec c5 97 33 66 cc85 17 2e 5c b8 6d da a9 4f 9e 21 42 84 15 2a 54a8 4d 9a 29 52 a4 55 aa 49 92 39 72 e4 d5 b7 73e6 d1 bf 63 c6 91 3f 7e fc e5 d7 b3 7b f6 f1 ffe3 db ab 4b 96 31 62 c4 95 37 6e dc a5 57 ae 4182 19 32 64 c8 8d 07 0e 1c 38 70 e0 dd a7 53 a651 a2 59 b2 79 f2 f9 ef c3 9b 2b 56 ac 45 8a 0912 24 48 90 3d 7a f4 f5 f7 f3 fb eb cb 8b 0b 162c 58 b0 7d fa e9 cf 83 1b 36 6c d8 ad 47 8e 01        对数表(0没有以2为底的对数):00 00 01 19 02 32 1a c6 03 df 33 ee 1b 68 c7 4b04 64 e0 0e 34 8d ef 81 1c c1 69 f8 c8 08 4c 7105 8a 65 2f e1 24 0f 21 35 93 8e da f0 12 82 451d b5 c2 7d 6a 27 f9 b9 c9 9a 09 78 4d e4 72 a606 bf 8b 62 66 dd 30 fd e2 98 25 b3 10 91 22 8836 d0 94 ce 8f 96 db bd f1 d2 13 5c 83 38 46 401e 42 b6 a3 c3 48 7e 6e 6b 3a 28 54 fa 85 ba 3dca 5e 9b 9f 0a 15 79 2b 4e d4 e5 ac 73 f3 a7 5707 70 c0 f7 8c 80 63 0d 67 4a de ed 31 c5 fe 18e3 a5 99 77 26 b8 b4 7c 11 44 92 d9 23 20 89 2e37 3f d1 5b 95 bc cf cd 90 87 97 b2 dc fc be 61f2 56 d3 ab 14 2a 5d 9e 84 3c 39 53 47 6d 41 a21f 2d 43 d8 b7 7b a4 76 c4 17 49 ec 7f 0c 6f f66c a1 3b 52 29 9d 55 aa fb 60 86 b1 bb cc 3e 5acb 59 5f b0 9c a9 a0 51 0b f5 16 eb 7a 75 2c d74f ae d5 e9 e6 e7 ad e8 74 d6 f4 ea a8 50 58 af        在计算 GF(2⁸) 中的乘法将 a, b 通过查对数表和指数表实现:              Galois-Field 的计算目前实现都是基于查表的,所以选择大的域虽然可以一次计算多个字节,但内存中随机访问一个大表也可能会造成cache miss太多而影响性能.              一般CPU都没有支持GF乘除法的指令, 但有些专用的硬件卡专门加速GF的乘除法.最新的CPU 逐渐开始加入GF乘除法支持了.      有了加减乘除的计算支持, 下一步就是实现EC的编解码.EC编码: 校验数据生成通常使用1个矩阵来表示输入和输出的关系(而不是像上文中只使用校验块的生成矩阵),这里选择1, 2, 3..生成的 Vandermonde 矩阵:这个矩阵里上面是1个大小为k的单位矩阵, 表示 dⱼ 的输入和输出不变.下面一部分是1个 m * k 的矩阵表示校验块的计算.对要存储的k组数据, 逐字节读入, 形成 d₁, d₂… , 进行矩阵乘法运算,得到最后要存储的 k 个数据块和 m 个校验块.  之所以把单位矩阵也放到编码矩阵上面, 看起来没有什么用,只是把输入无变化的输出出来的这种风格, 原因在于在编码理论中,并不是所有的生成的Code都是k个原始数据 和 m个校验数据的形式,有些编码算法是将k个输入变成完全不1样的k+m个输出, 对这类编码算法,需要1个k*(k+m)的编码矩阵来表示全部的转换过程.例如著名的 Hamming-7-4 编码的编码矩阵(输入k=4, 输出k+m=7):  EC解码当数据损坏时, 通过生成解码矩阵来恢复数据:对所有丢失的数据,将它对应的第i行从编码矩阵中移除,移除后, 保留编码矩阵的前k行,构成1个k*k的矩阵.例如第 2, 3个数据块丢失, 移除第2, 3行, 保留第k+1和k+2行:这时矩阵中数据块和校验块的关系是:最后求逆矩阵, 和没有丢失的块相乘, 就可以恢复出丢失的数据块 u₂, u₃:因为只有 u₂, u₃ 丢失了, 矩阵相乘时只需要计算逆矩阵的第2, 3行.Vandermonde 矩阵的可逆性在 第一篇:原理 中通提到:  Vandermonde 矩阵的任意 m * m 的子矩阵, 是一个Generalized Vandermonde Matrix, 它在 xᵢ 都为正数时可以保证永远有唯一解.但在GF(2⁸) 中不成立.举例来说, 以下矩阵是缺失 u₁, u₄ 情况下的用来恢复数据的矩阵,如果 x³ == 1, 它就不可逆.由于2是1个生成元,  容易看出, x = 2⁸⁵ 是1个不可逆的情况:x³ = 1 于是第1列和第4列完全一样.Cauchy 矩阵的可逆性  Cauchy 矩阵的任意n行n列组成的矩阵都是可逆的, 因为任意子矩阵还是 Cauchy矩阵.EC的实现到这里就结束了,有了GF(2⁸)的四则运算实现后, 再通过牛顿消元实现逆矩阵的求解,就可以完整的实现出一套EC算法了.在EC的计算中, 编解码是一个比较耗时的过程,因此业界也在不断寻找优化的方法, 不论从理论算法上还是从计算机指令的优化上,于是下一篇我们将介绍如何把EC实现为一个高效的实现.  EC擦除码系列:      第一篇:原理    第二篇:实现    第三篇:极限  ">







  <meta property="article:published_time" content="2020-02-04T00:00:00+08:00">





  

  


<link rel="canonical" href="https://blog.openacid.com/storage/ec-2/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "OpenACID-分布式研究小院",
      "url": "https://blog.openacid.com/"
    
  }
</script>






<!-- end _includes/seo.html -->


<link href="/feed.xml" type="application/atom+xml" rel="alternate" title="OpenACID Blog Feed">

<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->



    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<link rel="apple-touch-icon" sizes="180x180"    href="/assets/images/favicon/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
<link rel="manifest"                            href="/assets/images/favicon/site.webmanifest">

<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a>
    <a href="#main" class="screen-reader-shortcut">Skip to content</a>
    <a href="#footer" class="screen-reader-shortcut">Skip to footer</a>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo/icon-lemon-margin.png" alt=""></a>
        
        <a class="site-title" href="/">
          OpenACID Blog
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="https://github.com/orgs/openacid/people" >About Us</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <svg class="icon" width="16" height="16" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 15.99 16">
            <path d="M15.5,13.12L13.19,10.8a1.69,1.69,0,0,0-1.28-.55l-0.06-.06A6.5,6.5,0,0,0,5.77,0,6.5,6.5,0,0,0,2.46,11.59a6.47,6.47,0,0,0,7.74.26l0.05,0.05a1.65,1.65,0,0,0,.5,1.24l2.38,2.38A1.68,1.68,0,0,0,15.5,13.12ZM6.4,2A4.41,4.41,0,1,1,2,6.4,4.43,4.43,0,0,1,6.4,2Z" transform="translate(-.01)"></path>
          </svg>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">切换菜单</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="http://schema.org/Person">
  
  
  <p>

  
    <div class="author__avatar">
      

      
        <img src="/assets/images/author/xp.jpg" alt="张炎泼(xp)" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">张炎泼(xp)</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>正在学画画, 主业是码农</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">关注</button>
    <ul class="author__urls social-icons">
      

      
        
          
            <a href="https://drmingdrmer.github.io/" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i> 个人博客</a>
          
        
      

      

      

      

      

      

      

      

      

      

      

      
        
          <a href="https://github.com/drmingdrmer" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub
          </a>
        
      

      

      

      

      

      

      

      

      

      

      
        
          <a href="https://www.weibo.com/drdrxp" itemprop="sameAs" rel="nofollow noopener noreferrer">
            <i class="fab fa-fw fa-weibo" aria-hidden="true"></i> Weibo
          </a>
        
      

      

      

      

      <!--
  
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  
-->
    </ul>
  </div>

  </p>
  
</div>

  
  </div>


  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Erasure-Code-擦除码-2-实现篇">
    <meta itemprop="description" content="书接上回上一篇 第一篇:原理 中, 我们介绍了EC的基本原理,实际上EC的存储跟恢复过程可以理解为:一条k-1次曲线可以通过k个系数或曲线上的点来确定.我们也提到:  但这套理论还不能直接应用到线上产品中.因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,通过Vandermonde矩阵生成校验块, 那校验块的数值几乎确定会溢出.本文我们来解决这个问题, 看如何将EC的理论应用到计算机中, 保证计算不会溢出.  第一篇:原理 上一篇 🤔  第二篇:实现 我们在这 😁  第三篇:极限   🤔思路既然EC的存储过程就是对x取多个不同的值来计算y:恢复的过程是通过已知点的坐标来确定曲线方程:而编码和解码的过程都只需要加减乘除的四则运算(不需要开方),那么, 除了数字之外, 任何对象, 只要能对其进行四则运算,则都可以使用这种方法来实现冗余存储和备份.本文中我们就将通过将数字替换成另一种满足四则运算的东西,来实现计算机上的EC.我们先从简单的例子开始, 打开新世界的大门.  感谢19世纪伟大数学家 伽罗华.本文结构                ==&gt; : 同类概念                ──→ : 概念扩展┌──────────┬─────────────────────────────────────────────────────────┐│          │                                                         ││          │ digits: 0~9          ==&gt;  ┌→ GF(2): ℤ/(2) {0, 1}        ││  finite  │                           │                             ││     ↓    │  ↓                        │   ↓                         ││ infinite │                           │                             ││          │ integer: ℤ           ==&gt;  │  GF(2)[X]:                  ││          │ 10²a₂ + 10¹a₁ + a₀        │  a₂x² + a₁x + a₀            ││ infinite │                           │                             ││     ↓    │  ↓                        │   ↓               Goal!     ││   fixed  │                           │                  ↙          ││          │ GF(7): ℤ/(7) {0..6}  ==&gt;  │  GF(2⁸):  GF(2)[X]/(P₈(X))  ││          │ 5 ⊕ 4 = 2   ──────────────┘  (x+1) + (x) = 1            ││          │ 3 ⊗ 5 = 1                    x¹⁴=x⁴ + x + 1             ││          │                                                         │└──────────┴─────────────────────────────────────────────────────────┘GF(7): 伽罗华域Galois-Field GF(7)上面我们提到的几个数学公式, 高次曲线, 多元一次方程组等,他们之所以能正确的工作, 是因为他们依赖于一套底层的基础运算规则,这就是四则运算:  + - * /这听起来有点废话, 不用四则运算用什么?其实我们平时熟知的四则运算, 并不是唯一的四则运算法则例如在有1种四则运算可能是:5 + 5 = 3 而不是10,5 * 3 = 1 而不是15.栗子4: 只有7个数字的新世界: GF(7)🌰🌰 🌰🌰我们来尝试定义一个新的加法规则, 在这个新的世界里只有0~6这7个数字:其他整数进来时都要被模7, 变成0~6的数字.在这个模7的新世界里, 四则运算也可以工作:模7新世界中的 加法新的加法被表示为 ⊕ (这里原始的加法还是用+来表示):它定义为: a ⊕ b的结果是 a + b后结果再对7取模.例如:1 ⊕ 1 = 2 5 ⊕ 2 = 0 ( 7 % 7 = 0 ) 5 ⊕ 5 = 3 ( 10 % 7 = 3 )在这个新世界里, 0 还是和以前的0很相像, 任何数跟0相加都不变:0 ⊕ 3 = 3 2 ⊕ 0 = 20 在新世界 GF(7) 里被称为加法的单位元.模7新世界中的 减法然后我们再在模7的世界里定义减法.减法的定义也很直接, 就是加法的逆运算了.自然数里, -2 + 2 = 0, 我们称呼-2是2在加法上的逆元(通常称为相反数).在模7的世界里,我们也很容易找到每个数的加法逆元,例如:3 ⊕ 4 = 0所以 4 和 3 就互为加法的逆元.减法定义就是: $ a ⊖ b \rightarrow a ⊕ (-b) $.例如:3 ⊖ 4 = 3 ⊕ (-4) = 3 ⊕ 3 = 6 2 ⊖ 6 = 2 ⊕ (-6) = 2 ⊕ 1 = 3模7新世界中的 乘法 和 除法在模7的新世界里, 我们也可以类似地定义1个乘法:例如:1 ⊗ 5 = 5 ( 5 % 7 = 5 ) 3 ⊗ 4 = 5 ( 12 % 7 = 5 ) 2 ⊗ 5 = 3 ( 10 % 7 = 3 ) 0 ⊗ 6 = 6 ⊗ 0 = 0对于模7新世界的乘法⊗来说, 1 是乘法的单位元,也就是说1 ⊗ 任何数都是它本身.我们也可以用类似的方法定义每个数字在乘法⊗的逆元:a的乘法逆元 a⁻¹ = b, iff a ⊗ b = 1.例如:除法的定义就是: 乘以它的乘法逆元栗子5: 模7新世界直线方程-1🌰🌰 🌰🌰 🌰现在我们有了新的加法和减法⊕, ⊖ 我们可以像使用旧世界的加减法一样来使用⊕, ⊖.例如我们可以建立一个简单的, 斜率为1的直线方程:新世界里这个直线上的点是:(x,y) ∈ [(0,3), (1,4), (2,5), (3,6), (4,0), (5,1), (6,2)]只有7个.如果把这条直线画到坐标系里, 它应该是这个样子的:y = x ⊕ 3  y  ^6 |     •5 |   •4 | •3 •2 |           •1 |         •0 +-------•-----&gt; x  0 1 2 3 4 5 6栗子6: 模7新世界直线方程-2🌰🌰 🌰🌰 🌰🌰再加上新世界加减乘除四则运算, 我们可以在新世界里进行基本的代数运算了,例如我们可以设定1个斜率为2的直线方程:新世界里这个直线上的点是:(x,y) ∈ [(0,3), (1,5), (2,0), (3,2), (4,4), (5,6), (6,1)]这7个.如果把这条直线画到坐标系里, 它应该是这个样子的:y = 2 ⊗ x ⊕ 3  y  ^6 |          •5 | •4 |       •3 •2 |     •1 |           •0 +---•---------&gt; x  0 1 2 3 4 5 6栗子7: 模7新世界中的二次曲线方程🌰🌰 🌰🌰 🌰🌰 🌰下面我们来建立1个稍微复杂1点的, 二次曲线的方程:这里 x² 表示 x ⊗ x新世界里这个抛物线上的点集合是:(x,y) ∈ [(0, 2) (1, 4) (2, 1) (3, 0) (4, 1) (5, 4) (6, 2)]如果把这条抛物线画到坐标系里, 它应该是这个样子的:y = x^2 ⊕ x ⊕ 2  y  ^6 |5 |4 | •       •3 |2 •           •1 |   •   •0 +-----•-------&gt; x  0 1 2 3 4 5 6可以看出它的图像也遵循了旧世界抛物线的特性: 这条抛物线是以3为轴对称的:因为类似旧世界的多项式分解一样, 原方程也可以分解成:GF(7) 的EC实现在这个模7的新世界里, 它满足我们旧世界里的四则运算法则,我们已经可以使用前面(第一篇:原理)提到的 EC 的算法来编码或解码了:假设模7新世界里我们的数据块 d₁ = 3, d₂ = 2, 对应上面的直线方程:y = 2 ⊗ x ⊕ 3我们只要记住直线上2个点的位置, 就能把直线的方程恢复出来, 例如:我们先记录直线上2个点: (1,5) 和 (3,2)假设丢失的数据是 d₁, d₂ 用 u₁, u₂ 表示, 带入2个点的坐标,得到一个二元一次方程组:2个方程左右分别相减消元:最后得到 u₂ = 3 ⊗ 5⁻¹ = 3 ⊗ 3 = 2.将 u₂ = 2 带入第1个方程: 5 = 2 ⊗ 1 ⊕ u₁得到 u₁: u₁ = 5 ⊕ (-2) = 3是不是跟普通的一次方程组解法完全一样!至此, 我们用模7新世界的四则运算实现了之前的 EC . 并且我们保证了校验数据的大小是可控的:不会大于7!距离我们的目标又接近了1步.模7下的四则运算构成了1个 伽罗华域 Galois-Field: GF(7).简单来说, Galois-Field 是一个集合, 集合里的元素满足某种四则运算.摘自wikipedia上的解释:  A finite field is a set on which the operations of multiplication, addition, subtraction and division are defined  7是1个可选的数来通过取模的方式构造一个Galois-Field,也可以选择模11或其他质数来构造1个 Galois-Field,但是不能选择模一个合数来建立新的四则运算规则.假设使用模6, 模6世界里面的2是6的一个因子, 它没有乘法逆元, 也即是说2 乘以1~5任何一个数在模6的世界里都不是1.  没有乘法逆元就说明模6的世界里没有和旧世界里一样的除法,不能构成一个完整的四则运算体系.  为了简化, 四则里还有几个方面没有提到, 例如乘法加法的分配率.乘法和加法的结合律也必须满足, 才能在新世界里实现上面例子中的曲线方程等元素.这部分也很容验证,在上面的模7新世界里是可以满足的.现在我们有了 EC 的算法,以及很多个可以选择的四则运算来限定数值的范围.接下来要在计算机上实现,还有1步,就是:模7虽然可取,但是它没有办法对计算机里的数字有效利用,因为计算机里的数是二进制的.如果把数值限定到7或其他质数上,没有办法实现256或65536这样的区间的有效利用.所以接下来我们需要在所有四则运算里选择一个符合计算机的二进制的四则运算,作为实现 EC 计算的基础代数结构.从现在开始, 我们要构造一个现实中可用的伽罗华域,它比上面模7新世界稍微复杂一点, 得到这个域分为2步:      我们首先选择1个基础的,只包含2个元素的 Galois-Field GF(2): {0, 1}.        再在这个 GF(2) 的基础上建立1个有256个元素的 Galois-Field GF(2⁸).  GF(2): 模2的新世界: Galois-Field GF(2)首先选择了最小的Galois-Field GF(2), 类似于前面模7的例子, GF(2) 里的四则运算的定义为结果模2.它里面只有2个元素{0,1}:在这个GF(2)里, 运算的规则也非常简单:      加法(刚好和位运算的异或等价):    0 ⊕ 0 = 00 ⊕ 1 = 11 ⊕ 0 = 11 ⊕ 1 = 0        1的加法逆元就是1 本身.        乘法(刚好和位运算的与等价):    0 ⊗ 0 = 00 ⊗ 1 = 01 ⊗ 0 = 01 ⊗ 1 = 1        1的乘法逆元就是1 本身. 0 没有乘法逆元.  以这个GF(2)为基础, 可以构建一个1-bit的 EC 算法了:)  后面的讨论全部是依赖于GF(2)中的加法和乘法, 为了看起来清楚, 不再使用⊕和⊗了,直接使用传统的+, *来表示.GF(2) 的EC实现假设要存储的数据是:d₁ = 1, d₂ = 1对应直线方程是:y = 1 + x取2个点: x₁ = 0, x₂ = 1得到2个校验数据的值:y₁ = 1 + 0 = 1 y₂ = 1 + 1 = 0数据丢失后, 通过2个点的坐标找回直线方程系数:解得 u₁ = 1, u₂ = 1.下一步, 我们希望构建1个1 byte大小(2⁸ 个元素)的 Galois-Field GF(2⁸),在这个 GF(2⁸) 里的 EC 中,每个 dⱼ  和  yᵢ 的取值范围可以是0~255.但首先我们需要能表示比GF(2)更多的值.GF(2)[X] : GF(2) 作为系数的多项式类似于我们只需要0~9这10个自然数, 就可以通过增加进位这个概念后, 扩展成能表示任意大小的10进制整数一样(或用0~7表示任意大小的8进制数),我们通过类似的方法扩展{0,1}这2个数字, 表示更多的信息.引入多项式:使用 GF(2) 的元素作为系数, 定义1个多项式:系数 aᵢ 的四则运算还是遵循 GF(2) 的规则的,而多项式的四则运算, 显然是基于它的系数的四则运算建立的.例如多项式的加法:      因为 1 + 1 = 0, 所以: (x + 1) + (1) = x        x的同指数幂的系数相加遵循系数的Field的加法规则, 1 + 1 = 0:    (x² + x + 1) + (x) = x² + 1        2个相同的多项式相加肯定是0:    (x² + x + 1) + (x² + x + 1) = 0  多项式的乘法和旧世界的多项式乘法类似, 仍然是通过乘法的分配率展开多项式:多项式的除法依旧使用旧世界的多项式长除法法则,唯一不同仍旧是系数的四则运算是基于GF(2)的, 例如:多项式的除法的取余计算也类似, 因为 x² + x + 1 = x (x+1) + 1,所以: (x² + x + 1) = 1 mod (x+1) .我们看到, 多项式之间也是满足加减乘除四则运算的!  现在我们已经接触到了3种不同的四则运算:  GF(2)中元素的四则运算.GF(7)中元素的四则运算.GF(2) 多项式的四则运算.也就是说我们可以建议一个备份和恢复多项式的EC:GF(2)[X]的EC实现通过一个简单的例子来构建一个存储2个多项式的EC,将要存储的2个多项式作为系数建议一个直线:例如要存储的2个多项式 p₁ = x² + 1, p₂ = x,取直线上2个点, 例如X₁ X₂ 分别取1, x,代入直线方程得到2个Y的值:      存储过程:存储 p₁,  p₂, Y₁ Y₂;也就是: (x² + 1, x, x² + x + 1, 1)        恢复过程:假设 p₁, p₂ 都丢了,我们可以把Y₁, Y₂代入, 把p₁, p₂作为未知数建立一个方程组:  通过消元解方程, 两个方程相减, 恢复出p₂:这样我们就实现了一个基于多项式的EC了.但多项式的乘法依旧是有越界的问题的,如果自然数到模7的方法一样,我们需要把多项式的四则运算通过取模, 约束到一个可控的范围内.还是取模!GF(2⁸)GF(2)为系数的多项式的集合还不是一个伽罗华域,因为缺少除法逆元. 就像整数全集也不是一个伽罗华域,它也缺少除法逆元.  但在上面我们使用GF(2)的多项式来实现EC时, 没有触碰到没有乘法逆元这个问题.就像可以用2个整数作为分子分母来表示分数一样,用这种复合形式表示一个不存在的元素进行中间步骤的计算.  例如½不在整数集合, 但可以用1和2两个整数来表示出来.  而计算的最终结果都是恢复已存在的值, 所以分数形式的多项式最终都会被消去.但这种分数形式的表示方法在实际使用中会造成很大不便.现在我们需要找到1个质的多项式(Prime-Polynomial),来替代GF(7)中7的角色,最终得到1个有256个元素的多项式的伽罗华域 GF(2⁸).GF(2⁸) 类似于模7的方式, 将多项式模一个质的多项式(Prime-Polynomial)来得到:GF(2)[X]/(P₈(X))质的多项式(Prime-Polynomial) 简单说就是不可分解的多项式,例如 x² + 1 在实数域下就是 质多项式, 它无法分解成2个多项式乘积.GF(2) 下的质多项式      1 是1个质多项式.        x + 1 是1个质多项式.因为它最高次幂是1, 肯定不能再拆分成2个多项式乘积了.把所有GF(2)下的多项式对x + 1 取模, 只有2个可能的值: 0, 1.        x² + 1 不是一个质多项式, 它可以分解成(x + 1)².        2次的质多项式是: P₂(x) = x² + x + 1 .它在GF(2)的域中不能被拆分成2个1次多项式的乘积.    我们可以像使用7对所有整数取模那样, 用它对所有多项式取模,模它而产生的所有 余多项式, 是所有最高次幂小于2的多项式, 共有4个:0, 1, x, (x + 1).    模P₂(x)的多项式集合里, 同样满足多项式的四则运算.    对于其他j次幂的质多项式 Pⱼ(x),模Pⱼ(x)的多项式集合里, 也刚好有2ʲ 个元素.  GF(2) 扩张成 GF(2⁸)为了扩张到 GF(2⁸) 我们选择的8次幂的质多项式是:P₈(x) = x⁸ + x⁴ + x³ + x² + 1这个8次幂的质多项式,模它的所有余多项式,是所有最高次幂不超过7的多项式, 共256个,它就是 GF(2) 到 GF(2⁸) 的扩张.  Field-Extension 域的扩张, 简单来说就是通过把一个域(例如GF(2)),作为系数构建多项式, 再去模一个质多项式(如P₈(x)), 得到的余多项式集合(例如GF(2⁸)).  这里从一个2个数字的集合GF(2), 扩张之后得到的却是一个多项式的集合,因为在伽罗瓦的理论里, 数字跟多项式是没有区别的,因为他们都可以进行四则运算.就像我们前面也可以把多项式作为直线方程的系数一样.然后我们还发现, 因为多项式的系数是GF(2)下的元素, 只能是0或1.于是 这些多项式和二进制数是有一一对应关系的,多项式中指数为i的项的系数就是二进制数第i位的值:扩张后的元素对应0~255这256个二进制数, P₈(x) 对应:  二进制: 1 0001 1101  16进制: 0x11d而GF(2⁸)中的四则运算如下:      加法:a ⊕ b 对应多项式加法,同时它表示的二进制数的加法对应: a ^ b        乘法:a ⊗ b 对应多项式的乘法(模P₈(x)):  总结一下GF(2⁸)能够满足EC运算的几个性质:  加法单位元: 0  乘法单位元: 1  每个元素对加法都有逆元(可以实现减法): 逆元就是它本身( (x+1) + (x+1) = 0 )  每个元素对乘法都有逆元(除了0)(可以实现除法):P₈(x)是不可约的,因此不存在a和b都不是0但ab=0;又因为GF(2⁸)只有255个非0元素,因此对a,总能找到1个x使得 aˣ = a . 所以 aˣ⁻² a = 1.  aˣ⁻² 是a的乘法逆元.          PS, 看到 aˣ = a 是不是想起了费马小定理? :) 费马小定理的群论的证明        乘法和加法满足分配率: 基于多项式乘法和加法的定义.满足这些性质的四则运算, 就可以用GF(2⁸)来建立高次曲线, 进而在GF(2⁸)上实现EC.标准EC的实现以上讨论的是标准的EC的原理, 现在我们将以上的内容总结, 应用到实践上面.      标准的EC实现是基于GF(2)[X]/P(x), 一般基于 GF(2⁸) 或 GF(2¹⁶), GF(2³²), 分别对应1字节,2字节或4字节. 最常见的是GF(2⁸).        GF(2⁸) 下的加减法直接用异或计算, 不需要其他的工作.        GF(2⁸) 下的乘法和除法用查表的方式实现.    首先生成 GF(2⁸) 下对2的指数表和对数表,然后把乘除法转换成取对数和取幂的操作:    以 GF(2⁸) 为例:                  生成指数表 2⁰, 2¹, 2²… 的表,表中元素 pᵢ = 2^i.                    生成对数表, 表中元素 lᵢ = log₂i.              生成2个表的代码很简单, 用python表示如下:    power, log = [0] * 256, [0] * 256n = 1for i in range(0, 256):    power[i] = n    log[n] = i    n *= 2    # modular by the prime polynomial: P₈(x) = x⁸ + x⁴ + x³ + x² + 1    if n &gt;= 256:        n = n ^ 0x11dlog[1] = 0 # log[1] is 255, but it should be 0        指数表:01 02 04 08 10 20 40 80 1d 3a 74 e8 cd 87 13 264c 98 2d 5a b4 75 ea c9 8f 03 06 0c 18 30 60 c09d 27 4e 9c 25 4a 94 35 6a d4 b5 77 ee c1 9f 2346 8c 05 0a 14 28 50 a0 5d ba 69 d2 b9 6f de a15f be 61 c2 99 2f 5e bc 65 ca 89 0f 1e 3c 78 f0fd e7 d3 bb 6b d6 b1 7f fe e1 df a3 5b b6 71 e2d9 af 43 86 11 22 44 88 0d 1a 34 68 d0 bd 67 ce81 1f 3e 7c f8 ed c7 93 3b 76 ec c5 97 33 66 cc85 17 2e 5c b8 6d da a9 4f 9e 21 42 84 15 2a 54a8 4d 9a 29 52 a4 55 aa 49 92 39 72 e4 d5 b7 73e6 d1 bf 63 c6 91 3f 7e fc e5 d7 b3 7b f6 f1 ffe3 db ab 4b 96 31 62 c4 95 37 6e dc a5 57 ae 4182 19 32 64 c8 8d 07 0e 1c 38 70 e0 dd a7 53 a651 a2 59 b2 79 f2 f9 ef c3 9b 2b 56 ac 45 8a 0912 24 48 90 3d 7a f4 f5 f7 f3 fb eb cb 8b 0b 162c 58 b0 7d fa e9 cf 83 1b 36 6c d8 ad 47 8e 01        对数表(0没有以2为底的对数):00 00 01 19 02 32 1a c6 03 df 33 ee 1b 68 c7 4b04 64 e0 0e 34 8d ef 81 1c c1 69 f8 c8 08 4c 7105 8a 65 2f e1 24 0f 21 35 93 8e da f0 12 82 451d b5 c2 7d 6a 27 f9 b9 c9 9a 09 78 4d e4 72 a606 bf 8b 62 66 dd 30 fd e2 98 25 b3 10 91 22 8836 d0 94 ce 8f 96 db bd f1 d2 13 5c 83 38 46 401e 42 b6 a3 c3 48 7e 6e 6b 3a 28 54 fa 85 ba 3dca 5e 9b 9f 0a 15 79 2b 4e d4 e5 ac 73 f3 a7 5707 70 c0 f7 8c 80 63 0d 67 4a de ed 31 c5 fe 18e3 a5 99 77 26 b8 b4 7c 11 44 92 d9 23 20 89 2e37 3f d1 5b 95 bc cf cd 90 87 97 b2 dc fc be 61f2 56 d3 ab 14 2a 5d 9e 84 3c 39 53 47 6d 41 a21f 2d 43 d8 b7 7b a4 76 c4 17 49 ec 7f 0c 6f f66c a1 3b 52 29 9d 55 aa fb 60 86 b1 bb cc 3e 5acb 59 5f b0 9c a9 a0 51 0b f5 16 eb 7a 75 2c d74f ae d5 e9 e6 e7 ad e8 74 d6 f4 ea a8 50 58 af        在计算 GF(2⁸) 中的乘法将 a, b 通过查对数表和指数表实现:              Galois-Field 的计算目前实现都是基于查表的,所以选择大的域虽然可以一次计算多个字节,但内存中随机访问一个大表也可能会造成cache miss太多而影响性能.              一般CPU都没有支持GF乘除法的指令, 但有些专用的硬件卡专门加速GF的乘除法.最新的CPU 逐渐开始加入GF乘除法支持了.      有了加减乘除的计算支持, 下一步就是实现EC的编解码.EC编码: 校验数据生成通常使用1个矩阵来表示输入和输出的关系(而不是像上文中只使用校验块的生成矩阵),这里选择1, 2, 3..生成的 Vandermonde 矩阵:这个矩阵里上面是1个大小为k的单位矩阵, 表示 dⱼ 的输入和输出不变.下面一部分是1个 m * k 的矩阵表示校验块的计算.对要存储的k组数据, 逐字节读入, 形成 d₁, d₂… , 进行矩阵乘法运算,得到最后要存储的 k 个数据块和 m 个校验块.  之所以把单位矩阵也放到编码矩阵上面, 看起来没有什么用,只是把输入无变化的输出出来的这种风格, 原因在于在编码理论中,并不是所有的生成的Code都是k个原始数据 和 m个校验数据的形式,有些编码算法是将k个输入变成完全不1样的k+m个输出, 对这类编码算法,需要1个k*(k+m)的编码矩阵来表示全部的转换过程.例如著名的 Hamming-7-4 编码的编码矩阵(输入k=4, 输出k+m=7):  EC解码当数据损坏时, 通过生成解码矩阵来恢复数据:对所有丢失的数据,将它对应的第i行从编码矩阵中移除,移除后, 保留编码矩阵的前k行,构成1个k*k的矩阵.例如第 2, 3个数据块丢失, 移除第2, 3行, 保留第k+1和k+2行:这时矩阵中数据块和校验块的关系是:最后求逆矩阵, 和没有丢失的块相乘, 就可以恢复出丢失的数据块 u₂, u₃:因为只有 u₂, u₃ 丢失了, 矩阵相乘时只需要计算逆矩阵的第2, 3行.Vandermonde 矩阵的可逆性在 第一篇:原理 中通提到:  Vandermonde 矩阵的任意 m * m 的子矩阵, 是一个Generalized Vandermonde Matrix, 它在 xᵢ 都为正数时可以保证永远有唯一解.但在GF(2⁸) 中不成立.举例来说, 以下矩阵是缺失 u₁, u₄ 情况下的用来恢复数据的矩阵,如果 x³ == 1, 它就不可逆.由于2是1个生成元,  容易看出, x = 2⁸⁵ 是1个不可逆的情况:x³ = 1 于是第1列和第4列完全一样.Cauchy 矩阵的可逆性  Cauchy 矩阵的任意n行n列组成的矩阵都是可逆的, 因为任意子矩阵还是 Cauchy矩阵.EC的实现到这里就结束了,有了GF(2⁸)的四则运算实现后, 再通过牛顿消元实现逆矩阵的求解,就可以完整的实现出一套EC算法了.在EC的计算中, 编解码是一个比较耗时的过程,因此业界也在不断寻找优化的方法, 不论从理论算法上还是从计算机指令的优化上,于是下一篇我们将介绍如何把EC实现为一个高效的实现.  EC擦除码系列:      第一篇:原理    第二篇:实现    第三篇:极限  ">
    <meta itemprop="datePublished" content="February 04, 2020">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">Erasure-Code-擦除码-2-实现篇
</h1>
          
            <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  39 分钟阅读

</p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> 本文目录</h4></header>
              <ul class="toc__menu">
  <a href="#书接上回">书接上回</a>
  <a href="#思路">思路</a>
    <ul>
      <a href="#本文结构">本文结构</a>
    </ul>
  
  <a href="#gf7-伽罗华域galois-field-gf7">GF(7): 伽罗华域Galois-Field GF(7)</a>
    <ul>
      <a href="#栗子4-只有7个数字的新世界-gf7">栗子4: 只有7个数字的新世界: GF(7)</a>
        <ul>
          <a href="#模7新世界中的-加法">模7新世界中的 加法</a>
          <a href="#模7新世界中的-减法">模7新世界中的 减法</a>
          <a href="#模7新世界中的-乘法-和-除法">模7新世界中的 乘法 和 除法</a>
        </ul>
      
      <a href="#栗子5-模7新世界直线方程-1">栗子5: 模7新世界直线方程-1</a>
      <a href="#栗子6-模7新世界直线方程-2">栗子6: 模7新世界直线方程-2</a>
      <a href="#栗子7-模7新世界中的二次曲线方程">栗子7: 模7新世界中的二次曲线方程</a>
      <a href="#gf7-的ec实现">GF(7) 的EC实现</a>
    </ul>
  
  <a href="#gf2-模2的新世界-galois-field-gf2">GF(2): 模2的新世界: Galois-Field GF(2)</a>
    <ul>
      <a href="#gf2-的ec实现">GF(2) 的EC实现</a>
    </ul>
  
  <a href="#gf2x--gf2-作为系数的多项式">GF(2)[X] : GF(2) 作为系数的多项式</a>
    <ul>
      <a href="#gf2x的ec实现">GF(2)[X]的EC实现</a>
    </ul>
  
  <a href="#gf2">GF(2⁸)</a>
    <ul>
      <a href="#gf2-下的质多项式">GF(2) 下的质多项式</a>
      <a href="#gf2-扩张成-gf2">GF(2) 扩张成 GF(2⁸)</a>
    </ul>
  
  <a href="#标准ec的实现">标准EC的实现</a>
    <ul>
      <a href="#ec编码-校验数据生成">EC编码: 校验数据生成</a>
      <a href="#ec解码">EC解码</a>
      <a href="#vandermonde-矩阵的可逆性">Vandermonde 矩阵的可逆性</a>
      <a href="#cauchy-矩阵的可逆性">Cauchy 矩阵的可逆性</a>
    </ul>
  
</ul>
            </nav>
          </aside>
        
        <p style="font-size: 0.7rem; font-weight: bolder;">
本文链接: <a href="https://blog.openacid.com/storage/ec-2/">https://blog.openacid.com/storage/ec-2/</a>


</p>


        
          



<img src="/post-res/ec-2/ec-2-banner.png" alt="Erasure-Code-擦除码-2-实现篇" class="page__hero-image">

        

        <h1 id="书接上回">书接上回</h1>

<p>上一篇 <a href="https://blog.openacid.com/storage/ec-1" title="第一篇:Erasure-Code-擦除码-1-原理篇">第一篇:原理</a> 中, 我们介绍了EC的基本原理,
实际上EC的存储跟恢复过程可以理解为:
一条k-1次曲线可以通过k个系数或曲线上的点来确定.</p>

<p>我们也提到:</p>


  <p>但这套理论还不能直接应用到线上产品中.
因为计算机中还要考虑数字大小限制, 例如k个32位整数作为数据,
通过<a href="https://en.wikipedia.org/wiki/Vandermonde_matrix" title="Vandermonde matrix">Vandermonde</a>矩阵生成校验块, 那校验块的数值几乎确定会溢出.</p>


<p>本文我们来解决这个问题, 看如何将EC的理论应用到计算机中, 保证计算不会溢出.</p>

<ul>
  <a href="https://blog.openacid.com/storage/ec-1" title="第一篇:Erasure-Code-擦除码-1-原理篇">第一篇:原理</a> 上一篇 🤔
  <a href="https://blog.openacid.com/storage/ec-2" title="第二篇:Erasure-Code-擦除码-2-实现篇">第二篇:实现</a> 我们在这 😁
  <a href="https://blog.openacid.com/storage/ec-3" title="第三篇:Erasure-Code-擦除码-3-极限篇">第三篇:极限</a>   🤔
</ul>

<h1 id="思路">思路</h1>

<p>既然EC的存储过程就是对x取多个不同的值来计算y:</p>

<img src="/publish/weibo/storage/ec-2/images/y_=_d_1_d_2_x_d_3_x_2_d_k_x_k-1_-5471c2a2dae90c282fbadb0160c78e29.png" style="display: block; margin: 0 auto 1.3em auto" _alt="y = d_1 + d_2 x + d_3 x^2 + ... + d_k x^{k-1}"/>

<p>恢复的过程是通过已知点的坐标来确定曲线方程:</p>

<img src="/publish/weibo/storage/ec-2/images/begin_aligned_y_1_=_d_1_1_d_2_1_2_d_3_dots_1_k-1_d_k_y_2_=_d_1_-8122cb31101942c27bf14ccaf40bd68f.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{aligned}
y_1 = d_1 + 1 d_2  + 1^2 d_3  + \dots  1^{k-1} d_k \\
y_2 = d_1 + 2 d_2  + 2^2 d_3  + \dots  2^{k-1} d_k \\
y_3 = d_1 + 3 d_2  + 3^2 d_3  + \dots  3^{k-1} d_k \\
...
\end{aligned}"/>

<p>而编码和解码的过程都只需要加减乘除的四则运算(不需要开方),
那么, 除了数字之外, 任何对象, 只要能对其进行四则运算,
则都可以使用这种方法来实现冗余存储和备份.</p>

<p>本文中我们就将通过将数字替换成另一种满足四则运算的东西,
来实现计算机上的EC.</p>

<p>我们先从简单的例子开始, 打开新世界的大门.</p>


  <p>感谢19世纪伟大数学家 伽罗华.</p>


<h2 id="本文结构">本文结构</h2>

<div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_ed0a30bb4ca1d55465eb5d2c4892eacd.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div></div>

<h1 id="gf7-伽罗华域galois-field-gf7">GF(7): 伽罗华域<a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> GF(7)</h1>

<p>上面我们提到的几个数学公式, 高次曲线, 多元一次方程组等,
他们之所以能正确的工作, 是因为他们依赖于一套底层的基础运算规则,
这就是四则运算:  + - * /</p>

<p><strong>这听起来有点废话, 不用四则运算用什么</strong>?</p>

<p>其实我们平时熟知的四则运算, 并不是唯一的四则运算法则
例如在有1种四则运算可能是:
5 + 5 = 3 而不是10,
5 * 3 = 1 而不是15.</p>

<h2 id="栗子4-只有7个数字的新世界-gf7">栗子4: 只有7个数字的新世界: GF(7)</h2>

<p>🌰🌰 🌰🌰</p>

<p>我们来尝试定义一个新的加法规则, 在这个新的世界里只有0~6这7个数字:</p>

<p>其他整数进来时都要被模7, 变成0~6的数字.
在这个模7的新世界里, 四则运算也可以工作:</p>

<h3 id="模7新世界中的-加法">模7新世界中的 <strong>加法</strong></h3>

<p>新的加法被表示为 ⊕ (这里原始的加法还是用+来表示):</p>

<img src="/publish/weibo/storage/ec-2/images/a_b_rightarrow_a_b_pmod_7-f410bb0d891937478e93879df8a955d7.png" style="display: block; margin: 0 auto 1.3em auto" _alt="a ⊕ b \rightarrow (a + b) \pmod 7"/>

<p>它定义为: a ⊕ b的结果是 a + b后结果再对7取模.
例如:</p>

<p>1 ⊕ 1 = 2 <br />
5 ⊕ 2 = 0 ( 7 % 7 = 0 ) <br />
5 ⊕ 5 = 3 ( 10 % 7 = 3 )</p>

<p>在这个新世界里, 0 还是和以前的0很相像, 任何数跟0相加都不变:</p>

<p>0 ⊕ 3 = 3 <br />
2 ⊕ 0 = 2</p>

<p>0 在新世界 GF(7) 里被称为加法的<strong>单位元</strong>.</p>

<h3 id="模7新世界中的-减法">模7新世界中的 <strong>减法</strong></h3>

<p>然后我们再在模7的世界里定义减法.
减法的定义也很直接, 就是加法的逆运算了.</p>

<p>自然数里, -2 + 2 = 0, 我们称呼-2是2在加法上的逆元(通常称为相反数).
在模7的世界里,我们也很容易找到每个数的加法逆元,例如:
3 ⊕ 4 = 0
所以 4 和 3 就互为加法的逆元.</p>

<p>减法定义就是: $ a ⊖ b \rightarrow a ⊕ (-b) $.</p>

<p>例如:</p>

<p>3 ⊖ 4 = 3 ⊕ (-4) = 3 ⊕ 3 = 6 <br />
2 ⊖ 6 = 2 ⊕ (-6) = 2 ⊕ 1 = 3</p>

<h3 id="模7新世界中的-乘法-和-除法">模7新世界中的 <strong>乘法</strong> 和 <strong>除法</strong></h3>

<p>在模7的新世界里, 我们也可以类似地定义1个乘法:</p>

<img src="/publish/weibo/storage/ec-2/images/a_b_rightarrow_a_times_b_mod_7-3dd3b14fad173b6bebd8ec75f6f56349.png" style="display: block; margin: 0 auto 1.3em auto" _alt="a ⊗ b \rightarrow (a \times b) \mod 7"/>

<p>例如:</p>

<p>1 ⊗ 5 = 5 ( 5 % 7 = 5 ) <br />
3 ⊗ 4 = 5 ( 12 % 7 = 5 ) <br />
2 ⊗ 5 = 3 ( 10 % 7 = 3 ) <br />
0 ⊗ 6 = 6 ⊗ 0 = 0</p>

<p>对于模7新世界的乘法⊗来说, 1 是乘法的<strong>单位元</strong>,
也就是说1 ⊗ 任何数都是它本身.</p>

<p>我们也可以用类似的方法定义每个数字在乘法⊗的逆元:</p>

<p>a的乘法逆元 a⁻¹ = b, iff a ⊗ b = 1.</p>

<p>例如:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_3_-1_=_5_3_times_5_7_=_1_4_-1_=_2_4_times_2-7a0a85e88751f2073d4908655fde4626.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
3^{-1} & = 5 ( 3 \times 5 \% 7 = 1 ) \\
4^{-1} & = 2 ( 4 \times 2 \% 7 = 1 )
\end{aligned} %]]>"/>

<p>除法的定义就是: 乘以它的乘法逆元</p>

<h2 id="栗子5-模7新世界直线方程-1">栗子5: 模7新世界直线方程-1</h2>

<p>🌰🌰 🌰🌰 🌰</p>

<p>现在我们有了新的加法和减法⊕, ⊖ 我们可以像使用旧世界的加减法一样来使用⊕, ⊖.
例如我们可以建立一个简单的, 斜率为1的直线方程:</p>

<img src="/publish/weibo/storage/ec-2/images/y_=_x_3-9a613d0813f7b105ca7e83a271ed0d30.png" style="display: block; margin: 0 auto 1.3em auto" _alt="y = x ⊕ 3"/>

<p>新世界里这个直线上的点是:
(x,y) ∈ [(0,3), (1,4), (2,5), (3,6), (4,0), (5,1), (6,2)]
只有7个.</p>

<p>如果把这条直线画到坐标系里, 它应该是这个样子的:</p>

<div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_401a304708e0c9f86fba3f2798a45edb.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div></div>

<h2 id="栗子6-模7新世界直线方程-2">栗子6: 模7新世界直线方程-2</h2>

<p>🌰🌰 🌰🌰 🌰🌰</p>

<p>再加上新世界加减乘除四则运算, 我们可以在新世界里进行基本的代数运算了,
例如我们可以设定1个斜率为2的直线方程:</p>

<img src="/publish/weibo/storage/ec-2/images/y_=_2_x_3-452956f4bc3e129709a53fd3b602fb11.png" style="display: block; margin: 0 auto 1.3em auto" _alt="y = 2 ⊗ x ⊕ 3"/>

<p>新世界里这个直线上的点是:
(x,y) ∈ [(0,3), (1,5), (2,0), (3,2), (4,4), (5,6), (6,1)]
这7个.</p>

<p>如果把这条直线画到坐标系里, 它应该是这个样子的:</p>

<div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_8acc8c20474949fdc3bdc0591f90c929.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div></div>

<h2 id="栗子7-模7新世界中的二次曲线方程">栗子7: 模7新世界中的二次曲线方程</h2>

<p>🌰🌰 🌰🌰 🌰🌰 🌰</p>

<p>下面我们来建立1个稍微复杂1点的, 二次曲线的方程:</p>

<img src="/publish/weibo/storage/ec-2/images/y_=_x_2_x_2-50a9b1326f7ba723dfb7f3a0112709a6.png" style="display: block; margin: 0 auto 1.3em auto" _alt="y = x^2 ⊕ x ⊕ 2"/>

<p>这里 x² 表示 x ⊗ x</p>

<p>新世界里这个抛物线上的点集合是:
(x,y) ∈ [(0, 2) (1, 4) (2, 1) (3, 0) (4, 1) (5, 4) (6, 2)]</p>

<p>如果把这条抛物线画到坐标系里, 它应该是这个样子的:</p>

<div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_3ccf88f2528204ff37f6b888865608f3.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div></div>

<p>可以看出它的图像也遵循了旧世界抛物线的特性: <strong>这条抛物线是以3为轴对称的</strong>:
因为类似旧世界的多项式分解一样, 原方程也可以分解成:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_y_=_x_-3_2_=_x_2_-6_x_9_=_x_2_x_2_end_align-8599a374e402435658047db41c640355.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
y & = (x ⊕ (-3))^2 \\
  & = x^2 ⊕ (-6)x ⊕ 9 \\
  & = x^2 ⊕ x ⊕ 2
\end{aligned} %]]>"/>

<h2 id="gf7-的ec实现">GF(7) 的EC实现</h2>

<p>在这个模7的新世界里, 它满足我们旧世界里的四则运算法则,
我们已经可以使用前面(<a href="https://blog.openacid.com/storage/ec-1" title="第一篇:Erasure-Code-擦除码-1-原理篇">第一篇:原理</a>)提到的 EC 的算法来编码或解码了:</p>

<p>假设模7新世界里我们的数据块 d₁ = 3, d₂ = 2, 对应上面的直线方程:
y = 2 ⊗ x ⊕ 3</p>

<p>我们只要记住直线上2个点的位置, 就能把直线的方程恢复出来, 例如:</p>

<p>我们先记录直线上2个点: (1,5) 和 (3,2)</p>

<p>假设丢失的数据是 d₁, d₂ 用 u₁, u₂ 表示, 带入2个点的坐标,
得到一个二元一次方程组:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_cases_begin_aligned_5_=_u_2_u_1_2_=_u_2_3_u_1_end_a-1ffbda4d93abc692a0273ab53d5949a8.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{cases}
\begin{aligned}
5 & = u_2 ⊕ u_1 \\
2 & = u_2 ⊗ 3 ⊕ u_1
\end{aligned}
\end{cases} %]]>"/>

<p>2个方程左右分别相减消元:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_5_-2_=_u_2_1_-3_u_1_-u_1_5_5_=_u_2_1_4_3_=_-30e4456e8282bca3462c0e5023e8184d.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
5 ⊕ (-2) & = u_2 ⊗ (1 ⊕ (-3)) ⊕ u_1 ⊕ (-u_1) \\
   5 ⊕ 5 & = u_2 ⊗ (1 ⊕ 4) \\
       3 & = u_2 ⊗ 5
\end{aligned} %]]>"/>

<p>最后得到 u₂ = 3 ⊗ 5⁻¹ = 3 ⊗ 3 = 2.</p>

<p>将 u₂ = 2 带入第1个方程: 5 = 2 ⊗ 1 ⊕ u₁</p>

<p>得到 u₁: u₁ = 5 ⊕ (-2) = 3</p>

<p>是不是跟普通的一次方程组解法完全一样!</p>

<p>至此, 我们用模7新世界的四则运算实现了之前的 EC . 并且我们保证了校验数据的大小是可控的:
不会大于7!
距离我们的目标又接近了1步.</p>

<p>模7下的四则运算构成了1个 伽罗华域 <a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a>: GF(7).
简单来说, <a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> 是一个集合, 集合里的元素满足某种四则运算.
摘自wikipedia上的解释:</p>


  <p>A finite field is a set on which the operations of multiplication, addition, subtraction and division are defined</p>



  <p>7是1个可选的数来通过取模的方式构造一个Galois-Field,
也可以选择模11或其他质数来构造1个 <a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a>,
但是不能选择模一个合数来建立新的四则运算规则.
假设使用模6, 模6世界里面的2是6的一个因子, 它没有乘法逆元, 也即是说2 乘以
1~5任何一个数在模6的世界里都不是1.</p>

  <p>没有乘法逆元就说明模6的世界里没有和旧世界里一样的除法,
不能构成一个完整的四则运算体系.</p>



  <p>为了简化, 四则里还有几个方面没有提到, 例如乘法加法的分配率.
乘法和加法的结合律也必须满足, 才能在新世界里实现上面例子中的曲线方程等元素.
这部分也很容验证,在上面的模7新世界里是可以满足的.</p>


<p>现在我们有了 EC 的算法,
以及很多个可以选择的四则运算来限定数值的范围.
接下来要在计算机上实现,还有1步,就是:
模7虽然可取,但是它没有办法对计算机里的数字有效利用,因为计算机里的数是二进制的.
如果把数值限定到7或其他质数上,没有办法实现256或65536这样的区间的有效利用.</p>

<p>所以接下来我们需要在所有四则运算里选择一个符合计算机的二进制的四则运算,
作为实现 EC 计算的基础代数结构.</p>

<p>从现在开始, 我们要构造一个现实中可用的伽罗华域,
它比上面模7新世界稍微复杂一点, 得到这个域分为2步:</p>

<ul>
  <b>我们首先选择1个基础的,
只包含2个元素的 <a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> GF(2): {0, 1}.</b>
  
  <b>再在这个 GF(2) 的基础上建立1个有256个元素的 <a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> GF(2⁸).</b>
  
</ul>

<h1 id="gf2-模2的新世界-galois-field-gf2">GF(2): 模2的新世界: <a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> GF(2)</h1>

<p>首先选择了最小的<a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> GF(2), 类似于前面模7的例子, GF(2) 里的四则运算的定义为结果模2.
它里面只有2个元素{0,1}:</p>

<p>在这个GF(2)里, 运算的规则也非常简单:</p>

<ul>
  <b>加法(刚好和位运算的异或等价):</b>

    <div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_3fc7ae7313cf255d595f69ae947194e3.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div>    </div>

    <p>1的加法逆元就是1 本身.</p>
  
  <b>乘法(刚好和位运算的与等价):</b>

    <div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_5a25372088f3434cd17e580daf867d6d.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div>    </div>

    <p>1的乘法逆元就是1 本身. 0 没有乘法逆元.</p>
  
</ul>

<p>以这个GF(2)为基础, 可以构建一个1-bit的 EC 算法了:)</p>


  <p>后面的讨论全部是依赖于GF(2)中的加法和乘法, 为了看起来清楚, 不再使用⊕和⊗了,
直接使用传统的+, *来表示.</p>


<h2 id="gf2-的ec实现">GF(2) 的EC实现</h2>

<p>假设要存储的数据是:
d₁ = 1, d₂ = 1</p>

<p>对应直线方程是:
y = 1 + x</p>

<p>取2个点: x₁ = 0, x₂ = 1
得到2个校验数据的值:</p>

<p>y₁ = 1 + 0 = 1 <br />
y₂ = 1 + 1 = 0</p>

<p>数据丢失后, 通过2个点的坐标找回直线方程系数:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_1_=_u_1_0_u_2_0_=_u_1_1_u_2_end_aligned_-4e557e1b42e13d931c5e00027b0bdd2b.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
1 & = u_1 + 0 u_2 \\
0 & = u_1 + 1 u_2
\end{aligned} %]]>"/>

<p>解得 u₁ = 1, u₂ = 1.</p>

<p>下一步, 我们希望构建1个1 byte大小(2⁸ 个元素)的 <a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> GF(2⁸),
在这个 GF(2⁸) 里的 EC 中,
每个 dⱼ  和  yᵢ 的取值范围可以是0~255.</p>

<p>但首先我们需要能表示比GF(2)更多的值.</p>

<h1 id="gf2x--gf2-作为系数的多项式">GF(2)[X] : GF(2) 作为系数的多项式</h1>

<p>类似于我们只需要0~9这10个自然数, 就可以通过增加进位这个概念后, 
扩展成能表示任意大小的10进制整数一样(或用0~7表示任意大小的8进制数),
我们通过类似的方法扩展{0,1}这2个数字, 表示更多的信息.</p>

<p>引入多项式:</p>

<p>使用 GF(2) 的元素作为系数, 定义1个多项式:</p>

<img src="/publish/weibo/storage/ec-2/images/a_n_x_n_a_2_x_2_a_1_x_1_a_0_a_i_in_GF_2_=_0_1_-ed32b87099ad0ae53a19a6166469f8b9.png" style="display: block; margin: 0 auto 1.3em auto" _alt="a_n x^n + ... + a_2 x^2 + a_1 x^1 + a_0 \\
a_i \in GF(2) = \{0,1\}"/>

<p>系数 aᵢ 的四则运算还是遵循 GF(2) 的规则的,
而多项式的四则运算, 显然是基于它的系数的四则运算建立的.
例如多项式的加法:</p>

<ul>
  <b>因为 1 + 1 = 0, 所以: (x + 1) + (1) = x</b>
  
  <b>x的同指数幂的系数相加遵循系数的Field的加法规则, 1 + 1 = 0:</b>

    <p>(x² + x + 1) + (x) = x² + 1</p>
  
  <b>2个相同的多项式相加肯定是0:</b>

    <p>(x² + x + 1) + (x² + x + 1) = 0</p>
  
</ul>

<p>多项式的乘法和旧世界的多项式乘法类似, 仍然是通过乘法的分配率展开多项式:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_x_1_x_1_=_x_x_1_x_1_=_x_2_x_x_1_=_x_2_1_end-4bbbd66db25dff7fdf34380053c331a8.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
(x + 1) (x + 1) & = x (x+1) + (x+1) \\
                & = x^2 + x + x + 1 \\
                & = x^2 + 1
\end{aligned} %]]>"/>

<p>多项式的除法依旧使用旧世界的多项式长除法法则,
唯一不同仍旧是系数的四则运算是基于GF(2)的, 
例如:</p>

<img src="/publish/weibo/storage/ec-2/images/begin_aligned_frac_x_3_1_x_1_=_x_2_x_1_end_aligned_-6e1d2c6e798d082a7d965ec05ac6ff4c.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{aligned}
\frac{x^3 + 1}{x + 1} = x^2 + x + 1
\end{aligned}"/>

<p>多项式的除法的取余计算也类似, 因为 x² + x + 1 = x (x+1) + 1,
所以: (x² + x + 1) = 1 mod (x+1) .</p>

<p>我们看到, <strong>多项式之间也是满足加减乘除四则运算的</strong>!</p>


  <p>现在我们已经接触到了3种不同的四则运算:</p>

  <p>GF(2)中元素的四则运算.
GF(7)中元素的四则运算.
GF(2) 多项式的四则运算.</p>


<p>也就是说我们可以建议一个备份和恢复多项式的EC:</p>

<h2 id="gf2x的ec实现">GF(2)[X]的EC实现</h2>

<p>通过一个简单的例子来构建一个存储2个多项式的EC,
将要存储的2个<strong>多项式</strong>作为<strong>系数</strong>建议一个<strong>直线</strong>:</p>

<img src="/publish/weibo/storage/ec-2/images/Y_=_p_1_p_2_X-c4b58721aa750fe7c2686fe31322ab77.png" style="display: block; margin: 0 auto 1.3em auto" _alt="Y = p_1 + p_2 X"/>

<p>例如要存储的2个多项式 p₁ = x² + 1, p₂ = x,
取直线上2个点, 例如X₁ X₂ 分别取1, x,
代入直线方程得到2个Y的值:</p>

<img src="/publish/weibo/storage/ec-2/images/begin_cases_Y_1_=_p_1_p_2_1_=_x_2_1_x_1_=_x_2_x_1_Y_2_=_p_1_p_2-c184c2657b50e5d5a4b560e6ced49ec7.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{cases}
Y_1 = p_1 + p_2 (1) = x^2 + 1 + x (1) = x^2 + x + 1 \\
Y_2 = p_1 + p_2 (x) = x^2 + 1 + x (x) = 1
\end{cases}"/>

<ul>
  <b>存储过程:
存储 p₁,  p₂, Y₁ Y₂;
也就是: (x² + 1, x, x² + x + 1, 1)</b>
  
  <b>恢复过程:
假设 p₁, p₂ 都丢了,
我们可以把Y₁, Y₂代入, 把p₁, p₂作为未知数建立一个方程组:</b>
  
</ul>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_x_2_x_1_=_p_1_p_2_1_=_p_1_x_p_2_end_aligned-3ddbbf3edf38a3492b174b5cde61dda7.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
x^2 + x + 1 & = p_1 + p_2 \\
1           & = p_1 + x p_2
\end{aligned} %]]>"/>

<p>通过消元解方程, 两个方程相减, 恢复出p₂:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_x_2_x_1_-_1_=_p_1_-_p_1_p_2_-_x_p_2_x_2_x_=-db4e5d995a9a26b131b7c824a4a333bf.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
x^2 + x + 1 - 1     & = p_1 - p_1 + p_2 - x p_2 \\
x^2 + x             & = (1 - x) p_2                    \\
x^2 + x             & = (1 + x) p_2                    \\
\frac{x^2 + x}{1+x} & = p_2                           \\
x                   & = p_2
\end{aligned} %]]>"/>

<p>这样我们就实现了一个基于多项式的EC了.</p>

<p>但多项式的乘法依旧是有越界的问题的,
如果自然数到模7的方法一样,
我们需要把多项式的四则运算通过取模, 约束到一个可控的范围内.</p>

<p>还是取模!</p>

<h1 id="gf2">GF(2⁸)</h1>

<p>GF(2)为系数的多项式的集合还不是一个伽罗华域,
因为缺少除法逆元. 就像整数全集也不是一个伽罗华域,
它也缺少除法逆元.</p>


  <p>但在上面我们使用GF(2)的多项式来实现EC时, 没有触碰到没有乘法逆元这个问题.
就像可以用2个整数作为分子分母来表示分数一样,
用这种复合形式表示一个不存在的元素进行中间步骤的计算.</p>

  <p>例如½不在整数集合, 但可以用1和2两个整数来表示出来.</p>

  <p>而计算的最终结果都是恢复已存在的值, 所以分数形式的多项式最终都会被消去.
但这种分数形式的表示方法在实际使用中会造成很大不便.</p>


<p>现在我们需要找到1个质的多项式(<a href="https://en.wikipedia.org/wiki/Irreducible_polynomial" title="Prime-Polynomial">Prime-Polynomial</a>),
来替代GF(7)中<strong>7</strong>的角色,
最终得到1个有256个元素的多项式的伽罗华域 GF(2⁸).</p>

<p>GF(2⁸) 类似于模7的方式, 将多项式模一个质的多项式(<a href="https://en.wikipedia.org/wiki/Irreducible_polynomial" title="Prime-Polynomial">Prime-Polynomial</a>)来得到:
GF(2)[X]/(P₈(X))</p>

<p>质的多项式(<a href="https://en.wikipedia.org/wiki/Irreducible_polynomial" title="Prime-Polynomial">Prime-Polynomial</a>) 简单说就是不可分解的多项式,
例如 x² + 1 在<strong>实数域</strong>下就是 <strong>质多项式</strong>, 它无法分解成2个多项式乘积.</p>

<h2 id="gf2-下的质多项式">GF(2) 下的质多项式</h2>

<ul>
  <b>1 是1个质多项式.</b>
  
  <b>x + 1 是1个质多项式.
因为它最高次幂是1, 肯定不能再拆分成2个多项式乘积了.
把所有GF(2)下的多项式对x + 1 取模, 只有2个可能的值: 0, 1.</b>
  
  <b>x² + 1 不是一个质多项式, 它可以分解成(x + 1)².</b>
  
  <b>2次的质多项式是: P₂(x) = x² + x + 1 .
它在GF(2)的域中不能被拆分成2个1次多项式的乘积.</b>

    <p>我们可以像使用7对所有整数取模那样, 用它对所有多项式取模,
模它而产生的所有 <strong>余多项式</strong>, 是所有最高次幂小于2的多项式, 共有4个:
0, 1, x, (x + 1).</p>

    <p>模P₂(x)的多项式集合里, 同样满足多项式的四则运算.</p>

    <p>对于其他j次幂的质多项式 Pⱼ(x),
模Pⱼ(x)的多项式集合里, 也刚好有2ʲ 个元素.</p>
  
</ul>

<h2 id="gf2-扩张成-gf2">GF(2) 扩张成 GF(2⁸)</h2>

<p>为了扩张到 GF(2⁸) 我们选择的8次幂的质多项式是:
P₈(x) = x⁸ + x⁴ + x³ + x² + 1</p>

<p>这个8次幂的质多项式,模它的所有余多项式,是所有最高次幂不超过7的多项式, 共256个,
它就是 GF(2) 到 GF(2⁸) 的扩张.</p>


  <p><a href="https://en.wikipedia.org/wiki/Field_extension" title="Field-Extension">Field-Extension</a> 域的扩张, 简单来说就是通过把一个域(例如GF(2)),
作为系数构建多项式, 再去模一个质多项式(如P₈(x)), 得到的<strong>余多项式</strong>集合(例如GF(2⁸)).</p>

  <p>这里从一个2个数字的集合GF(2), 扩张之后得到的却是一个多项式的集合,
因为在伽罗瓦的理论里, 数字跟多项式是没有区别的,
因为他们都可以进行四则运算.
就像我们前面也可以把多项式作为直线方程的系数一样.</p>


<p>然后我们还发现, 因为多项式的系数是GF(2)下的元素, 只能是0或1.
于是 <strong>这些多项式和二进制数是有一一对应关系的</strong>,
多项式中指数为i的项的系数就是二进制数第i位的值:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_aligned_1_rightarrow_1_x_2_1_rightarrow_101_x_3_x_r-af33b12ff3d38ae41b0d9fcfe81a18b5.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{aligned}
      1 & \rightarrow    1 \\
x^2 + 1 & \rightarrow  101 \\
x^3 + x & \rightarrow 1010
\end{aligned} %]]>"/>

<p>扩张后的元素对应0~255这256个二进制数, P₈(x) 对应:</p>

<ul>
  二进制: 1 0001 1101
  16进制: 0x11d
</ul>

<p>而GF(2⁸)中的四则运算如下:</p>

<ul>
  <b>加法:
a ⊕ b 对应多项式加法,
同时它表示的二进制数的加法对应: a ^ b</b>
  
  <b>乘法:
a ⊗ b 对应多项式的乘法(模P₈(x)):</b>
  
</ul>

<p>总结一下GF(2⁸)能够满足EC运算的几个性质:</p>

<ul>
  加法单位元: 0
  乘法单位元: 1
  每个元素对加法都有逆元(可以实现减法): 逆元就是它本身( (x+1) + (x+1) = 0 )
  每个元素对乘法都有逆元(除了0)(可以实现除法):P₈(x)是不可约的,
因此不存在a和b都不是0但ab=0;
又因为GF(2⁸)只有255个非0元素,
因此对a,总能找到1个x使得 aˣ = a . 所以 aˣ⁻² a = 1.  aˣ⁻² 是a的乘法逆元.
    
      <p>PS, 看到 aˣ = a 是不是想起了费马小定理? :) <a href="https://en.wikipedia.org/wiki/Proofs_of_Fermat%27s_little_theorem#Proofs_using_group_theory" title="费马小定理的群论的证明">费马小定理的群论的证明</a></p>
    
  
  乘法和加法满足分配率: 基于多项式乘法和加法的定义.
</ul>

<p>满足这些性质的四则运算, 就可以用GF(2⁸)来建立高次曲线, 进而在GF(2⁸)上实现EC.</p>

<h1 id="标准ec的实现">标准EC的实现</h1>

<p>以上讨论的是标准的EC的原理, 现在我们将以上的内容总结, 应用到实践上面.</p>

<ul>
  <b>标准的EC实现是基于GF(2)[X]/P(x), 一般基于 GF(2⁸) 或 GF(2¹⁶), GF(2³²), 分别对应1字节,
2字节或4字节. 最常见的是GF(2⁸).</b>
  
  <b>GF(2⁸) 下的加减法直接用异或计算, 不需要其他的工作.</b>
  
  <b>GF(2⁸) 下的乘法和除法用查表的方式实现.</b>

    <p>首先生成 GF(2⁸) 下对2的指数表和对数表,
然后把乘除法转换成取对数和取幂的操作:</p>

    <p>以 GF(2⁸) 为例:</p>

    <ul>
      <b>生成指数表 2⁰, 2¹, 2²… 的表,
表中元素 pᵢ = 2^i.</b>
      
      <b>生成对数表, 表中元素 lᵢ = log₂i.</b>
      
    </ul>

    <p>生成2个表的代码很简单, 用python表示如下:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_06e606e0d475fc277ac97ff67ffb0f64.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div>    </div>

    <div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_de26344c67e42b06bf8042ea5016249b.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div>    </div>

    <div class="highlighter-rouge"><div class="highlight"><img src="/publish/weibo/storage/ec-2/images/tbl_df6ecc775dd3e04e0a0b404fa79cd9ae.png" style="display: block; margin: 0 auto 1.3em auto" _alt="table"/></div>    </div>

    <p>在计算 GF(2⁸) 中的乘法
将 a, b 通过查对数表和指数表实现:</p>

    <img src="/publish/weibo/storage/ec-2/images/begin_aligned_a_b_=_2_log_2a_log_2b_a_b_=_2_log_2a-log_2b_end_a-34255bf57ac7b6cbf7b0316020b13c12.png" style="display: block; margin: 0 auto 1.3em auto" _alt="\begin{aligned}
a * b = 2^{log_2a+log_2b} \\
a / b = 2^{log_2a-log_2b}
\end{aligned}"/>

    
      <p><a href="https://en.wikipedia.org/wiki/Finite_field" title="Galois-Field">Galois-Field</a> 的计算目前实现都是基于查表的,
所以选择大的域虽然可以一次计算多个字节,
但内存中随机访问一个大表也可能会造成cache miss太多而影响性能.</p>
    

    
      <p>一般CPU都没有支持GF乘除法的指令, 但有些专用的硬件卡专门加速GF的乘除法.
最新的CPU 逐渐开始加入GF乘除法支持了.</p>
    
  
</ul>

<p>有了加减乘除的计算支持, 下一步就是实现EC的编解码.</p>

<h2 id="ec编码-校验数据生成">EC编码: 校验数据生成</h2>

<p>通常使用1个矩阵来表示输入和输出的关系
(而不是像上文中只使用校验块的生成矩阵),
这里选择1, 2, 3..生成的 <a href="https://en.wikipedia.org/wiki/Vandermonde_matrix" title="Vandermonde matrix">Vandermonde</a> 矩阵:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_bmatrix_1_0_0_dots_0_0_1_0_dots_0_0_0_1_dots_0_vdot-333f90a5453b984238c66f2f8b5381b8.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{bmatrix}
1      & 0      & 0      & \dots  & 0       \\
0      & 1      & 0      & \dots  & 0       \\
0      & 0      & 1      & \dots  & 0       \\
\vdots & \vdots & \vdots & \ddots & \vdots  \\
0      & 0      & 0      & \dots  & 1       \\
\hline \\
1      & 1      & 1      & \dots  & 1       \\
1      & 2      & 2^2    & \dots  & 2^{k-1} \\
1      & 3      & 3^2    & \dots  & 3^{k-1} \\
\vdots & \vdots & \vdots & \ddots & \vdots  \\
1      & m      & m^2    & \dots  & m^{k-1}
\end{bmatrix}
\times
\begin{bmatrix}
d_1 \\
d_2 \\
d_3 \\
... \\
d_k
\end{bmatrix} =
\begin{bmatrix}
d_1 \\
d_2 \\
d_3 \\
... \\
d_k \\
y_1 \\
y_2 \\
y_3 \\
... \\
y_m
\end{bmatrix} %]]>"/>

<p>这个矩阵里上面是1个大小为k的单位矩阵, 表示 dⱼ 的输入和输出不变.</p>

<p>下面一部分是1个 m * k 的矩阵表示校验块的计算.</p>

<p>对要存储的k组数据, 逐字节读入, 形成 d₁, d₂… , 进行矩阵乘法运算,
得到最后要存储的 k 个数据块和 m 个校验块.</p>


  <p>之所以把单位矩阵也放到编码矩阵上面, 看起来没有什么用,
只是把输入无变化的输出出来的这种风格, 原因在于在编码理论中,
并不是所有的生成的Code都是k个原始数据 和 m个校验数据的形式,
有些编码算法是将k个输入变成完全不1样的k+m个输出, 对这类编码算法,
需要1个k*(k+m)的编码矩阵来表示全部的转换过程.
例如著名的 <a href="https://en.wikipedia.org/wiki/Hamming(7,4)" title="Hamming(7, 4)">Hamming-7-4</a> 编码的编码矩阵(输入k=4, 输出k+m=7):</p>

  <img src="/publish/weibo/storage/ec-2/images/CDATA_begin_pmatrix_1_1_0_1_1_0_1_1_1_0_0_0_0_1_1_1_0_1_0_0_0_0-ca876cd4e26069fcccdbc001f14e4c1a.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{pmatrix}
1&1&0&1\\
1&0&1&1\\
1&0&0&0\\
0&1&1&1\\
0&1&0&0\\
0&0&1&0\\
0&0&0&1\\
\end{pmatrix} %]]>"/>


<h2 id="ec解码">EC解码</h2>

<p>当数据损坏时, 通过生成解码矩阵来恢复数据:</p>

<p>对所有丢失的数据,
将它对应的第i行从编码矩阵中移除,
移除后, 保留编码矩阵的前k行,
构成1个k*k的矩阵.</p>

<p>例如第 2, 3个数据块丢失, 移除第2, 3行, 保留第k+1和k+2行:
这时矩阵中数据块和校验块的关系是:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_bmatrix_1_0_0_0_dots_0_0_0_0_1_dots_0_vdots_vdots_v-3cb52d0332523e77d8526012d6d8763b.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{bmatrix}
1      & 0      & 0      & 0      & \dots  & 0       \\
0      & 0      & 0      & 1      & \dots  & 0       \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots  \\
0      & 0      & 0      & 0      & \dots  & 1       \\
1      & 1      & 1      & 1      & \dots  & 1       \\
1      & 2      & 2^2    & 2^3    & \dots  & 2^{k-1} \\
\end{bmatrix}
\times
\begin{bmatrix}
d_1 \\
u_2 \\
u_3 \\
d_4 \\
... \\
d_k
\end{bmatrix} =
\begin{bmatrix}
d_1 \\
d_4 \\
... \\
d_k \\
y_1 \\
y_2 \\
\end{bmatrix} %]]>"/>

<p>最后求逆矩阵, 和没有丢失的块相乘, 就可以恢复出丢失的数据块 u₂, u₃:</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_bmatrix_d_1_u_2_u_3_d_4_d_k_end_bmatrix_=_begin_bma-a9b9ca1d2be5363f372d90b28546087f.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{bmatrix}
d_1 \\
u_2 \\
u_3 \\
d_4 \\
... \\
d_k
\end{bmatrix} =
\begin{bmatrix}
1      & 0      & 0      & 0      & \dots  & 0       \\
0      & 0      & 0      & 1      & \dots  & 0       \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots  \\
0      & 0      & 0      & 0      & \dots  & 1       \\
1      & 1      & 1      & 1      & \dots  & 1       \\
1      & 2      & 2^2    & 2^3    & \dots  & 2^{k-1} \\
\end{bmatrix}^{-1}
\times
\begin{bmatrix}
d_1 \\
d_4 \\
... \\
d_k \\
y_1 \\
y_2 \\
\end{bmatrix} %]]>"/>

<p>因为只有 u₂, u₃ 丢失了, 矩阵相乘时只需要计算逆矩阵的第2, 3行.</p>

<h2 id="vandermonde-矩阵的可逆性">Vandermonde 矩阵的可逆性</h2>

<p>在 <a href="https://blog.openacid.com/storage/ec-1" title="第一篇:Erasure-Code-擦除码-1-原理篇">第一篇:原理</a> 中通提到:</p>


  <p><a href="https://en.wikipedia.org/wiki/Vandermonde_matrix" title="Vandermonde matrix">Vandermonde</a> 矩阵的任意 m * m 的子矩阵, 是一个Generalized Vandermonde Matrix,
 它在 xᵢ 都为正数时可以保证永远有唯一解.</p>


<p>但在GF(2⁸) 中不成立.</p>

<p>举例来说, 以下矩阵是缺失 u₁, u₄ 情况下的用来恢复数据的矩阵,
如果 x³ == 1, 它就不可逆.</p>

<p>由于2是1个生成元,  容易看出, x = 2⁸⁵ 是1个不可逆的情况:
x³ = 1 于是第1列和第4列完全一样.</p>

<img src="/publish/weibo/storage/ec-2/images/CDATA_begin_bmatrix_0_1_0_0_0_0_0_1_0_0_0_0_0_0_1_1_1_1_1_1_1_x-4d9260292b6b0915afc85724f225b933.png" style="display: block; margin: 0 auto 1.3em auto" _alt="% <![CDATA[
\begin{bmatrix}
0      & 1      & 0      & 0      & 0   \\
0      & 0      & 1      & 0      & 0   \\
0      & 0      & 0      & 0      & 1   \\
1      & 1      & 1      & 1      & 1   \\
1      & x      & x^2    & x^3    & x^4 \\
\end{bmatrix} %]]>"/>

<h2 id="cauchy-矩阵的可逆性">Cauchy 矩阵的可逆性</h2>

  <p>Cauchy 矩阵的任意n行n列组成的矩阵都是可逆的, 因为任意子矩阵还是 Cauchy矩阵.</p>


<p>EC的实现到这里就结束了,
有了GF(2⁸)的四则运算实现后, 再通过牛顿消元实现逆矩阵的求解,
就可以完整的实现出一套EC算法了.</p>

<p>在EC的计算中, 编解码是一个比较耗时的过程,
因此业界也在不断寻找优化的方法, 不论从理论算法上还是从计算机指令的优化上,
于是下一篇我们将介绍如何把EC实现为一个高效的实现.</p>


  <p>EC擦除码系列:</p>
  <ul>
    <a href="https://blog.openacid.com/storage/ec-1" title="第一篇:Erasure-Code-擦除码-1-原理篇">第一篇:原理</a>
    <a href="https://blog.openacid.com/storage/ec-2" title="第二篇:Erasure-Code-擦除码-2-实现篇">第二篇:实现</a>
    <a href="https://blog.openacid.com/storage/ec-3" title="第三篇:Erasure-Code-擦除码-3-极限篇">第三篇:极限</a>
  </ul>



        <p style="font-size: 0.7rem; font-weight: bolder;">
本文链接: <a href="https://blog.openacid.com/storage/ec-2/">https://blog.openacid.com/storage/ec-2/</a>


</p>
<ul class="page-links" style="display:none;">




    
        <li style="font-size:0.7em">
        [Vandermonde]: https://en.wikipedia.org/wiki/Vandermonde_matrix
        </li>
    

    
        <li style="font-size:0.7em">
        [Cauchy]: https://en.wikipedia.org/wiki/Cauchy_matrix
        </li>
    

    
        <li style="font-size:0.7em">
        [failure-rate]: https://www.backblaze.com/blog/hard-drive-reliability-stats-q1-2016/
        </li>
    

    
        <li style="font-size:0.7em">
        [RAID]: https://zh.wikipedia.org/wiki/RAID
        </li>
    

    
        <li style="font-size:0.7em">
        [RAID-5]: https://zh.wikipedia.org/wiki/RAID#RAID_5
        </li>
    

    
        <li style="font-size:0.7em">
        [RAID-6]: https://zh.wikipedia.org/wiki/RAID#RAID_6
        </li>
    

    
        <li style="font-size:0.7em">
        [Finite-Field]: https://en.wikipedia.org/wiki/Finite_field
        </li>
    

    
        <li style="font-size:0.7em">
        [Galois-Field]: https://en.wikipedia.org/wiki/Finite_field
        </li>
    

    
        <li style="font-size:0.7em">
        [Reed-Solomon]: https://en.wikipedia.org/wiki/Reed%E2%80%93Solomon_error_correction
        </li>
    

    
        <li style="font-size:0.7em">
        [Erasure-Code]: https://en.wikipedia.org/wiki/Erasure_code
        </li>
    

    
        <li style="font-size:0.7em">
        [Prime-Polynomial]: https://en.wikipedia.org/wiki/Irreducible_polynomial
        </li>
    

    
        <li style="font-size:0.7em">
        [Field-Extension]: https://en.wikipedia.org/wiki/Field_extension
        </li>
    

    
        <li style="font-size:0.7em">
        [Complex-Number]: https://en.wikipedia.org/wiki/Irreducible_polynomial#Field_extension
        </li>
    

    
        <li style="font-size:0.7em">
        [Hamming-7-4]: https://en.wikipedia.org/wiki/Hamming(7,4)
        </li>
    

    
        <li style="font-size:0.7em">
        [Generator-Matrix]: https://en.wikipedia.org/wiki/Generator_matrix
        </li>
    

    
        <li style="font-size:0.7em">
        [第一篇:原理]: https://blog.openacid.com/storage/ec-1
        </li>
    

    
        <li style="font-size:0.7em">
        [第二篇:实现]: https://blog.openacid.com/storage/ec-2
        </li>
    

    
        <li style="font-size:0.7em">
        [第三篇:极限]: https://blog.openacid.com/storage/ec-3
        </li>
    

    
        <li style="font-size:0.7em">
        [费马小定理的群论的证明]: https://en.wikipedia.org/wiki/Proofs_of_Fermat%27s_little_theorem#Proofs_using_group_theory
        </li>
    

</ul>
<p>
<img src="/assets/images/qrcode-hori.jpg" alt="openacid">
</p>

        
      </section>

      <footer class="page__meta">
        
        
  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> 标签: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/tags/#distributed" class="page__taxonomy-item" rel="tag">distributed</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#ec" class="page__taxonomy-item" rel="tag">ec</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#erasure-code" class="page__taxonomy-item" rel="tag">erasure-code</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#gf256" class="page__taxonomy-item" rel="tag">GF256</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#replication" class="page__taxonomy-item" rel="tag">replication</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#storage" class="page__taxonomy-item" rel="tag">storage</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#%E4%BC%BD%E7%BD%97%E7%93%A6" class="page__taxonomy-item" rel="tag">伽罗瓦</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#%E4%BC%BD%E7%BD%97%E7%93%A6%E5%9F%9F" class="page__taxonomy-item" rel="tag">伽罗瓦域</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#%E5%9F%9F" class="page__taxonomy-item" rel="tag">域</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#%E6%93%A6%E9%99%A4%E7%A0%81" class="page__taxonomy-item" rel="tag">擦除码</a><span class="sep">, </span>
    
      
      
      <a href="/tags/#%E7%BA%A0%E5%88%A0%E7%A0%81" class="page__taxonomy-item" rel="tag">纠删码</a>
    
    </span>
  </p>




  


  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> 分类: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#storage" class="page__taxonomy-item" rel="tag">storage</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> 更新时间:</strong> <time datetime="2020-02-04T00:00:00+08:00">February 04, 2020</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">分享</h4>
  

  <a href="https://twitter.com/intent/tweet?text=Erasure-Code-%E6%93%A6%E9%99%A4%E7%A0%81-2-%E5%AE%9E%E7%8E%B0%E7%AF%87%20https%3A%2F%2Fblog.openacid.com%2Fstorage%2Fec-2%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Fblog.openacid.com%2Fstorage%2Fec-2%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Fblog.openacid.com%2Fstorage%2Fec-2%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="分享 LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/storage/ec-1/" class="pagination--pager" title="Erasure-Code-擦除码-1-原理篇
">向前</a>
    
    
      <a href="/storage/ec-3/" class="pagination--pager" title="Erasure-Code-擦除码-3-极限篇
">向后</a>
    
  </nav>

    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">留下评论</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">猜您还喜欢</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/algo/quorum/" rel="permalink">后分布式时代: 多数派读写的’少数派’实现
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  21 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">通过减少多数派读写中参与者的数量, 可以实现分布式系统某些特定场景的优化, 以及介绍这些优化对系统可用性产生的影响, 根据什么标准来选择和调整这些参数.
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/algo/paxos/" rel="permalink">可靠分布式系统-paxos的直观解释
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  13 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">没有paxos的一堆机器, 只能叫做分布式; 有paxos协同才叫分布式系统. 咱得把paxos聊开了聊透了
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/tech/bla/programmer-should-know/" rel="permalink">几个无理取闹的coding心得
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  2 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">来自一个莫得感情的coding万年户
</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
        <a href="/storage/ec-3/" rel="permalink">Erasure-Code-擦除码-3-极限篇
</a>
      
    </h2>
    
      <p class="page__meta"><i class="far fa-clock" aria-hidden="true"></i> 




  25 分钟阅读

</p>
    
    <p class="archive__item-excerpt" itemprop="description">没有人比我更懂EC(特辣脯口气): 从指令集和算法两个方向对擦除码实现深度优化, 硬核但不烧脑
</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><form class="search-content__form" onkeydown="return event.key != 'Enter';">
    <label class="sr-only" for="search">
      Enter your search term...
    </label>
    <input type="search" id="search" class="search-input" tabindex="-1" placeholder="输入您要搜索的关键词..." />
  </form>
  <div id="results" class="results"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->



<script language="javascript" type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/SVG"],
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true
        }
    });
</script>
<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_SVG"> </script>




<!-- end custom footer snippets -->

        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <strong>关注:</strong>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    <a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2020 OpenACID-分布式研究小院. 技术来自于 <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>
  <script src="https://kit.fontawesome.com/4eee35f757.js"></script>




<script src="/assets/js/lunr/lunr.min.js"></script>
<script src="/assets/js/lunr/lunr-store.js"></script>
<script src="/assets/js/lunr/lunr-en.js"></script>




  <script>
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-69976993-2']);
  
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>






    
  <script>
    var disqus_config = function () {
      this.page.url = "https://blog.openacid.com/storage/ec-2/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = "/storage/ec-2"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://openacid.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>


  





  <style> .header-link { display: none !important; } </style> </body >
</html>
